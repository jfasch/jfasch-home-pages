<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://www.faschingbauer.me</id>
  <title>Jörg Faschingbauer - Posts in embedded</title>
  <updated>2021-06-17T12:22:07.953519+00:00</updated>
  <link href="https://www.faschingbauer.me"/>
  <link href="https://www.faschingbauer.me/blog/category/embedded/atom.xml"/>
  <generator uri="https://ablog.readthedocs.org" version="0.10.12">ABlog</generator>
  <entry>
    <id>https://www.faschingbauer.me/blog/2010/07/beagleboard-how-to-repair-nand-also-known-as-40w.html</id>
    <title>Beagleboard: How to Repair NAND (also known as 40W)</title>
    <updated>2010-07-30T00:00:00+02:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;div class="section" id="beagleboard-how-to-repair-nand-also-known-as-40w"&gt;

&lt;div class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#basics" id="id1"&gt;Basics&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#getting-x-loader-and-u-boot" id="id2"&gt;Getting X-Loader and U-Boot&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#creating-a-bootable-mmc-sd-card" id="id3"&gt;Creating a Bootable MMC/SD card&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#repairing-the-nand" id="id4"&gt;Repairing the NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#writing-x-loader-to-nand" id="id5"&gt;Writing X-Loader to NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#writing-u-boot-to-nand" id="id6"&gt;Writing U-Boot to NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It happened again. Friends of mine have an alias,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;alias faschingbauer=&amp;quot;rm -rf ~&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;in their &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;.bashrc&lt;/span&gt;&lt;/code&gt; for a couple of years now, and now I created a
creative variation thereof.&lt;/p&gt;
&lt;p&gt;I used to have my beagleboard running happily off an SD card, using a
root filesystem which I had updated natively from a &lt;a class="reference external" href="http://mirrors.kernel.org/gentoo/releases/arm/autobuilds/current-stage3/armv4tl-softfloat-linux-gnueabi/"&gt;Gentoo ARM stage3&lt;/a&gt;. This
is decadent, so I prepared a Busybox-only initramfs linked into the
kernel image (cross-built of course, as opposed to the stage3), with
the plans to use this as an alternative boot image residing in NAND
flash.&lt;/p&gt;
&lt;p&gt;It happened to me that, during finding out the correct arguments of
U-Boot’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt; command, I hit the
return key early - expecting that a sole&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;nand erase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;would give me further instructions. U-Boot took it literally though
and erased NAND, just like I told it to. A reboot showed the fatal
consequences. “40W” was the only thing I saw over the serial terminal
(115200/8N1 by the way).&lt;/p&gt;
&lt;p&gt;Here in the remainder I write down how to recover from such a
fauxpas. The internet has a lot of explanations, but none of them is a
walk-through from the beginning to the end. You’ll have to do a couple
of things, and most of the instructions you’ll find don’t explain
much. This is not what I like, so I researched a bit and write the
annotated collected instructions down right here. You might find it
useful - I surely will once I’ll brick my beagle again.&lt;/p&gt;
&lt;div class="section" id="basics"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Basics&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The OMAP has a small boot ROM inside. This is the first of the chain
of boot loaders, and it’s where the CPU core jumps to when it’s done
with whatever CPU cores do when they are powered on). The boot ROM is
programmed to load a second stage boot loader (the “X-Loader” as it is
called) into the processor’s SRAM. X-Loader is then responsible for
loading another stage - U-Boot in the Linux case - into the external
DRAM. It’s the latter two stages - X-Loader and U-Boot - that I
faschingbauered away from NAND, and that I’ll recover now.&lt;/p&gt;
&lt;p&gt;They key to all that is the ability of the boot ROM to boot from a
MMC/SD card when the user button is pressed during its operation. We
will prepare one such card, put the boot files on it, and write these
to NAND.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="getting-x-loader-and-u-boot"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Getting X-Loader and U-Boot&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The beagleboard guys wrote up a page with &lt;a class="reference external" href="http://code.google.com/p/beagleboard/wiki/BeagleboardRevC3Validation"&gt;board validation
instructions&lt;/a&gt;. This
is where I have most of the information from. There they give links to
the images that I want. Take care that you select the ones that match
your board revision; the files they use on that page are slightly
seasoned. I have a recent C4, and I found it valuable to have a recent
U-Boot version that enables power on the USB host controller. This was
a change they made from C3 to C4, for example - take care.&lt;/p&gt;
&lt;p&gt;Anyway, &lt;a class="reference external" href="http://www.angstrom-distribution.org/demo/beagleboard/"&gt;Angstrom&lt;/a&gt; have the
most recent stuff. Download X-Loader and U-Boot from there, and
additionally another bootloader stage, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, which is used during
the MMC boot. The filenames change, just browse the directory a choose
something that sounds like &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;x-load.bin.ift&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot*&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO*&lt;/span&gt;&lt;/code&gt;. Save them away for later use. I saved them as
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;x-load.bin.ift&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot.bin&lt;/span&gt;&lt;/code&gt;, and it’s these names that I
refer to later on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="creating-a-bootable-mmc-sd-card"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Creating a Bootable MMC/SD card&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For basic card configuration I refer you to &lt;a class="reference external" href="http://processors.wiki.ti.com/index.php/MMC_Boot_Format"&gt;a TI maintained page&lt;/a&gt; which is
very concise and to the point, and where there is nothing much left to
say. I followed the instruction using fdisk, and obvoiusly the card
can be read by the boot ROM. There are reports that FAT32 does not
work on some cards, and that selecting FAT16 instead helped. You might
want to try that out in case.&lt;/p&gt;
&lt;p&gt;Once the card is ready and a FAT partition has been created, you mount
that partition and put the files on it as follows.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;First comes &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, as file &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, no matter what name you stored
it under on your disk. It is read by the boot ROM, and that one is
very particular that the file is found in the first sectors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You store the U-Boot image as file &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot.bin&lt;/span&gt;&lt;/code&gt;. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt; expects
it under that name during MMC boot. (If you intend to use a
different U-Boot image for NAND then you store that one under a
different name which you use further down when we write NAND.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The X-Loader is not used during MMC boot, so you can choose any name
you like.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Insert the card into the MMC/SD slot of the beagle, and boot. In case
you erased your NAND only partly and there is still something
meaningful in it, be sure to hold down the user button to force the
boot ROM to boot from the card.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="repairing-the-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Repairing the NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The following is taken from the &lt;a class="reference external" href="http://beagleboard.googlecode.com/files/reset_revc_v3.scr"&gt;reset.scr&lt;/a&gt; U-Boot
script referred to by the &lt;a class="reference external" href="http://code.google.com/p/beagleboard/wiki/BeagleboardRevC3Validation"&gt;beagleboard validation instructions&lt;/a&gt;. I
took care to annotate as much as possible in order to understand the
steps.&lt;/p&gt;
&lt;p&gt;First off, we initialize MMC/SD.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # mmc init&lt;/span&gt;
&lt;span class="go"&gt;mmc1 is available&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To understand where the numbers in the remainder instructions come
from, open the kernel source file
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;arch/arm/mach-omap2/board-omap3beagle.c&lt;/span&gt;&lt;/code&gt;. I’ll refer to that file
in the remainder explanations. Near the top of the file you’ll notice
the partition table; you’ll find it insightful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-x-loader-to-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Writing X-Loader to NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First, erase the X-Loader partition. According to the partition table,
it starts at offset 0 (where the OMAP’s boot ROM expects it) and is
4*128K=0x80000 bytes long.&lt;/p&gt;
&lt;p&gt;The boot ROM relies on hardware to manage error correction code (ECC),
as described in the &lt;a class="reference external" href="http://download.micron.com/pdf/technotes/nand/tn2916.pdf"&gt;tech note&lt;/a&gt;, so we
select it.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nandecc hw&lt;/span&gt;
&lt;span class="go"&gt;HW ECC selected&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 0 80000&lt;/span&gt;
&lt;span class="go"&gt;NAND erase: device 0 offset 0x0, size 0x80000&lt;/span&gt;
&lt;span class="go"&gt;Erasing at 0x60000 -- 100% complete.&lt;/span&gt;
&lt;span class="go"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;According to the &lt;a class="reference external" href="http://download.micron.com/pdf/technotes/nand/tn2916.pdf"&gt;tech note&lt;/a&gt; again,
the OMAP’s boot ROM takes care of bad blocks (unlikely because an
intermediate bootloader isn’t written to flash that often, but
nevertheless it sounds like a good idea). It checks the first four
blocks of the X-Loader partition for a valid image, so we write the
image into these four blocks. Again, the erase block size is
determined by looking in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;board-omap3beagle.c&lt;/span&gt;&lt;/code&gt; - 128K = 0x20000.&lt;/p&gt;
&lt;p&gt;Read the image into memory, and write it out 4 times, in the first
four erase blocks of the partition.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # fatload mmc 0 80200000 x-load.bin.ift&lt;/span&gt;
&lt;span class="go"&gt;reading x-load.bin.ift&lt;/span&gt;
&lt;span class="go"&gt;20392 bytes read&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 0 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x0, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 20000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x20000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 40000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x40000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 60000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x60000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-u-boot-to-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Writing U-Boot to NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Can’t find which ECC incarnation the X-Loader uses, software seems to
be the choice (sounds like the do-nothing-and-cross-fingers approach).&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nandecc sw&lt;/span&gt;
&lt;span class="go"&gt;SW ECC selected&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;According to the kernel sources, U-Boot’s partition starts at offset
0x80000 and is 15*128K=0x1e0000 bytes long.&lt;/p&gt;
&lt;p&gt;Erase NAND, load U-Boot from card, write it to the partition.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 80000 1e0000&lt;/span&gt;
&lt;span class="go"&gt;NAND erase: device 0 offset 0x80000, size 0x1e0000&lt;/span&gt;
&lt;span class="go"&gt;Erasing at 0x240000 -- 100% complete.&lt;/span&gt;
&lt;span class="go"&gt;OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # fatload mmc 0 80200000 u-boot.bin&lt;/span&gt;
&lt;span class="go"&gt;reading u-boot.bin&lt;/span&gt;
&lt;span class="go"&gt;275928 bytes read&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 80000 1e0000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x80000, size 0x1e0000&lt;/span&gt;
&lt;span class="go"&gt;1966080 bytes written: OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That’s it. You are now able to boot without the card, up to the U-Boot
prompt.&lt;/p&gt;
&lt;p&gt;Take care when you flash the kernel. In case you don’t know the
correct &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt; parameters, write&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # help nand&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;instead of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt;. I suggest you type&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 280000 400000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;just like the kernel source says for the kernel partition.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2010/07/beagleboard-how-to-repair-nand-also-known-as-40w.html" rel="alternate"/>
    <published>2010-07-30T00:00:00+02:00</published>
  </entry>
  <entry>
    <id>https://www.faschingbauer.me/blog/2011/01/porting-to-linux-there-s-always-a-better-way.html</id>
    <title>Porting to Linux (There’s Always A Better Way)</title>
    <updated>2011-01-07T00:00:00+01:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;div class="section" id="porting-to-linux-there-s-always-a-better-way"&gt;

&lt;div class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#processes-are-threads" id="id1"&gt;Processes are Threads&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#signals-aren-t-messages" id="id2"&gt;Signals Aren’t Messages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#message-queues-aren-t-message-queues" id="id3"&gt;Message Queues aren’t Message Queues&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#semaphores-and-mutexes" id="id4"&gt;Semaphores and Mutexes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#timers" id="id5"&gt;Timers&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#polling" id="id6"&gt;Polling&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#event-dispatching" id="id7"&gt;Event Dispatching&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#interrupts" id="id8"&gt;Interrupts&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#realtime" id="id9"&gt;Realtime&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Over the past months I met a couple of people who are relatively new
to Linux. For one, I’ve been to Germany doing courses on Linux -
naturally the audience in such a course is new to Linux. For another,
I have one and a half customers here in Austria who are mainly doing
microcontroller work and who don’t have a clue of Linux.&lt;/p&gt;
&lt;p&gt;Many of these people have code which they have written and maintained
over a long time, and which has a value. The code runs happily on bare
metal, or on a minimal OS like Segger embOS, Enea OSE, VxWorks, or
even Windows CE. No way rewriting it just because of Linux.&lt;/p&gt;
&lt;p&gt;Well, there’s no need to. It’s just not trivial to choose the right
mechanisms. Linux (and Unix in general) offers so many choices to mess
things up right from the beginning. And it’s quite likely that things
are in fact messed up, which is what I learned from the people I met.&lt;/p&gt;
&lt;p&gt;“Good Old Device Firmware” is quite limited in what it can use.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;It is a statically linked blob of executable code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It operates in a single address space (there’s generally no idea
what an address space is, so there is only one).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It has interrupts hammering on it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If there is an OS, then chances are that there are multiple
processes that are scheduled by the OS. Often processes communicate
by dumping messages into each other’s message queues.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Locking mechanisms. In the presence of interrupts you need to
disable them if need be. If processes are used, there are generally
semaphores available in one or more flavors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s these simple concepts where the confusion starts. For example,
in Linux/Unix a process is probably not what you want - you rather
want a thread instead. When you search for the term “message queue”
you will find &lt;em&gt;several&lt;/em&gt; mechanisms, &lt;em&gt;none of which&lt;/em&gt; are what you
want. You’ll notice sooner or later that you chose the wrong
concept, but it’s maybe too late to revert - causing your Linux port
to fail over the years. (In my opinion it’s never too late to
revert, but that’s a different kind of story.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the remainder I’ll try to give a list of recipes for porting to
Linux. I hope that it will help you speed up the porting project, by
avoiding severe mistakes right at the beginning. The list cannot be
complete - it’s just a blog post after all. But I do hope it will give
you a bigger picture than you already have, and that it provides you
with the starting points for your own research (which you will have to
do unless you want to hire me as a consultant :-).&lt;/p&gt;
&lt;div class="section" id="processes-are-threads"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Processes are Threads&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the embedded OS world, you use the word “process” to refer to an
entity that is scheduled by the OS. There is no such thing as separate
address spaces and memory protection in such systems (these OS’s are
initially designed for cheap MMU-less processors).&lt;/p&gt;
&lt;p&gt;So, what people generally want is &lt;em&gt;threads&lt;/em&gt;. &lt;em&gt;Processes&lt;/em&gt; in Unix refer
to address space separation and memory protection, so don’t get misled
only by the term. The Unix way of multithreading is POSIX threads
(pthreads for short). On Linux, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;pthreads&lt;/span&gt;&lt;/code&gt; will tell you
more. Better yet, buy yourself a copy of a &lt;a class="reference external" href="http://oreilly.com/catalog/9781565921153"&gt;PThreads Programming&lt;/a&gt; book. Read that book
twice. Threading has lots of pitfalls, and it is crucial to understand
these. (I have seen people create five threads to solve a simple
data-acquisition-and-network-communication problem where they didn’t
know what a mutex was.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="signals-aren-t-messages"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Signals Aren’t Messages&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Don’t use Unix signals for communication. They have very few in common
with what’s called a &lt;em&gt;signal&lt;/em&gt; in RTOSs. (In the RTOS world, &lt;em&gt;signals&lt;/em&gt;
are often called &lt;em&gt;messages&lt;/em&gt;.)&lt;/p&gt;
&lt;div class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_signals/slides.html"&gt;&lt;span class="doc"&gt;Slide material: UNIX signals&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_signals/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: UNIX signals&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;In Unix, signals are commonly used to tear down a process (&lt;em&gt;not&lt;/em&gt; a
thread), giving it a chance to perform proper cleanup before
exit. There are other uses of signals as well, such as notification of
memory protection violation (the dreaded “segmentation fault”) and
other programming errors.&lt;/p&gt;
&lt;p&gt;The problem with signal handling is that signals arrive in a special
context which you probably know as “interrupt context” in your
OS. Consequently, your options are very limited in a signal
handler. You cannot use most of the functions that are available from
the C runtime library!&lt;/p&gt;
&lt;p&gt;If you still feel that you need to use signals, then perform the
following steps.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Think twice. Why do you need signals? There’s probably a better way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Read &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;-s&lt;/span&gt; &lt;span class="pre"&gt;7&lt;/span&gt; &lt;span class="pre"&gt;signal&lt;/span&gt;&lt;/code&gt; for more. &lt;strong&gt;Pay special attention to the
section about async-signal-safe functions&lt;/strong&gt; (note that none of the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_&lt;/span&gt;&lt;/code&gt; functions appears in the list).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Try to defer processing from the signal handler into the regular
course of your application. For example, you can use the “self pipe”
trick (Google sure knows about it.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Forget about asynchronous signal delivery and use one of the``
sigwait``, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigwaitinfo&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigtimedwait&lt;/span&gt;&lt;/code&gt; system calls. This
way you suspend the execution of one thread until a signal is
caught, thus turning signal handling into a &lt;em&gt;synchronous&lt;/em&gt;
approach. You’d have to dedicate an entire thread to signal handling
though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An alternative way of synchronous signal handling is to use the new
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;signalfd&lt;/span&gt;&lt;/code&gt; system call. Its semantics are the same as
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigwaitinfo&lt;/span&gt;&lt;/code&gt;, only you use a file descriptor as an “event
source”. You can embed this file descriptor among other event
sources in an event driven application, using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt;,
or &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;epoll&lt;/span&gt;&lt;/code&gt;. See below for more.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="message-queues-aren-t-message-queues"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Message Queues aren’t Message Queues&lt;/a&gt;&lt;/h2&gt;
&lt;div class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_ipc/slides.html"&gt;&lt;span class="doc"&gt;Slide material: POSIX message queues&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_ipc/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: POSIX message queues&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Chances are that the threads (err, processes) of your OS communicate
via messages queues over which messages (err, signals) are sent. A
naive Google search (“Linux message queues”) will lead you to POSIX
and System V message queues, both of which are inter process
communication (IPC) mechanisms. This is probably not what you want, as
your messages need not be transferred across different address
spaces. Intra process message queues are normally built on top of
pthread primitives. You can find a sample such implementation &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=pthread/base/message-queue.h"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="semaphores-and-mutexes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Semaphores and Mutexes&lt;/a&gt;&lt;/h2&gt;
&lt;div class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_ipc/slides.html"&gt;&lt;span class="doc"&gt;Slide material: POSIX semaphores&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/sysprog/sysprog_ipc/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: POSIX semaphores&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Many of those OSs out there have semaphores as the one and only
synchronisation mechanism. Linux has semaphores - System V and POSIX
style. Again these are probably not what you want. You are likely to
initialize your semaphores with a count of one and use it as a &lt;em&gt;binary
semaphore&lt;/em&gt;. This is what a pthread mutex is for instead.&lt;/p&gt;
&lt;p&gt;See &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;pthread_mutex_init&lt;/span&gt;&lt;/code&gt; for more.&lt;/p&gt;
&lt;p&gt;Confusing note for those porting from Windows: A &lt;em&gt;critical section&lt;/em&gt; is
the region that is protected by a mutex, although a
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CRITICAL_SECTION&lt;/span&gt;&lt;/code&gt; is the closest Windows pendant to a mutex.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="timers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Timers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Timers are hard, not only on Linux.&lt;/p&gt;
&lt;p&gt;In most embedded OSs, timers expire as interrupts which are then
handled by the application. Sometimes there is the possibility to let
the OS send you a message (err, signal) on timer expiration.&lt;/p&gt;
&lt;p&gt;There are multiple APIs for timers, most of which (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;setitimer&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;timer_create&lt;/span&gt;&lt;/code&gt;) require you to use signals (Unix signals this
time) - see above for the drawbacks to this approach. Unfortunately a
straightforward Google search will lead you to these APIs.&lt;/p&gt;
&lt;p&gt;An alternative is to simply defer the execution of a thread for a
specified amount of time, using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nanosleep&lt;/span&gt;&lt;/code&gt;. Another alternative is
to use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;timerfd_create&lt;/span&gt;&lt;/code&gt; and friends in conjunction with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;
or &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt;, and embed timers into an event driven application. (See
below for event loops based on file descriptors. See &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=linux-events/events/timer.h"&gt;here&lt;/a&gt;
for a sample implementation of such a thing.)&lt;/p&gt;
&lt;p&gt;You can always build your own structures around whatever timer
mechanism and emulate the behavior of your OS on Linux. This might
require quite a bit of understanding of Linux programming, though.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="polling"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Polling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Polling for something to happen is generally the most stupid thing to
do, not only on Linux. The are cases (screwed hardware for example)
where there is no other way, but otherwise there’s always a better
way.&lt;/p&gt;
&lt;p&gt;I have seen people set a flag in one process (err, thread), and poll
for it every millisecond from another thread. I know, a millisecond is
an eternity in nowadays’ processors - but I can imagine that there are
more flags of that sort being polled for, in a moderately complex
program. After all, it’s &lt;em&gt;events&lt;/em&gt; that these flags communicate. Some
OSs have an “event flag” mechanism which tries to achieve exactly
that, albeit a bit more intelligently - for example without the need
for polling, and without losing events through race conditions.&lt;/p&gt;
&lt;p&gt;There’s a big wealth of mechanisms in Linux to communicate events. Use
message queues (see above), for example. Build your own “event flag”
mechanism by using PThreads primitives (but not before you have read
the book).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="event-dispatching"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Event Dispatching&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On Unix, &lt;em&gt;everything is a file&lt;/em&gt;. Entire disks are represented as
files, partitions are, network sockets are, arbitrary devices are (for
example, serial/UART lines). Regular files are, naturally. On Linux,
even timers and Unix signals can be represented as files, as I
mentioned previously. Every open file is represented as a &lt;em&gt;file
descriptor&lt;/em&gt;. File descriptors can be read from and written to, using
the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;read&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;write&lt;/span&gt;&lt;/code&gt; system calls, regardless of their type.&lt;/p&gt;
&lt;p&gt;For people who are new to Unix, this may come as a surprise: you can
read from a serial line as if it were a network connection, and you
can read from a network connection as if it were a regular
file. (Anyone tried that on Windows?)&lt;/p&gt;
&lt;p&gt;This fact alone is something you can take advantage of in your porting
project.&lt;/p&gt;
&lt;p&gt;Now what has this got to do with &lt;em&gt;event dispatching&lt;/em&gt;? Consider the
following types of &lt;em&gt;events&lt;/em&gt; that regularly happen on an OS:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Network connection has data to be read.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Network connection can be written to without blocking (or, “local
TCP buffer just got emptied” or so).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Same with serial IO (open &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/dev/ttyS0&lt;/span&gt;&lt;/code&gt; or so just like a regular
file), as with any kind of stream connection.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A timer has expired.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A signal has arrived.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An arbitrary event happened (check out the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;eventfd&lt;/span&gt;&lt;/code&gt; system call;
I didn’t mention it).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Even USB events are delivered via files. (It’s just a bit more
complicated because USB is a bit more complicated; there’s &lt;a class="reference external" href="http://www.libusb.org/"&gt;libusb&lt;/a&gt; there to handle this.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Most drivers for hardware devices deliver the device interrupts as
events through file descriptors (you open &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/dev/blah&lt;/span&gt;&lt;/code&gt; just like a
regular file), nicely telling you “Hey, I’ve got to tell you
something!”.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is a set of system calls that are used to wait for events on
&lt;em&gt;multiple&lt;/em&gt; file descriptor, namely &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;,`` poll``, and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;epoll&lt;/span&gt;&lt;/code&gt;. Note that these system call put the calling process (err,
thread) to sleep until something happens - the name &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt; has
nothing to do with polling as we know it.&lt;/p&gt;
&lt;p&gt;So, depending on your application, you might find it relatively easy
to use either of these system calls. Build a bit of an infrastructure
around it, like registering and unregistering callbacks, and you will
be able to comfortably use these extremely exciting mechanisms. (Or
take &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=events/dispatcher.h"&gt;my own infrastructure&lt;/a&gt;. Or
take anybody else’s, mine’s not the only - it’s just the best.)&lt;/p&gt;
&lt;p&gt;One last note: look at the desktop environment of your choice. It’s
made up of a hundred or so processes (no, not threads). Under Gnome,
which is what I use, there’s a process called`` gnome-panel``, for
example. Try out &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;strace&lt;/span&gt; &lt;span class="pre"&gt;-p&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;pid&lt;/span&gt; &lt;span class="pre"&gt;of&lt;/span&gt; &lt;span class="pre"&gt;gnome-panel&amp;gt;;&lt;/span&gt;&lt;/code&gt;, direct the mouse
over the panel, and see what happens: &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt; all over.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="interrupts"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Interrupts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One of the primary goals of an OS is to shield you from
hardware. There a clear separation between &lt;em&gt;user space&lt;/em&gt; and &lt;em&gt;kernel
space&lt;/em&gt;. User space uses system calls to talk to the kernel. No
interrupts in user space. Basta. (Don’t even think about using
signals!)&lt;/p&gt;
&lt;p&gt;If you have hardware that nobody else has, then chances are you will
have to deal with it yourself and write a driver for it. That’s about
the only case where you’ll get in touch with interrupts and have to
learn kernel programming. But this is a completely different story,
and a different world. Definitely fun.&lt;/p&gt;
&lt;p&gt;Nevertheless, I suggest you stay away from kernel programming just
because it is fun. Debugging is much harder there. A buggy user space
program crashes, possibly leaving you with a core dump that you can
examine with a debugger (well, GDB). Everything else will remain
running. A buggy kernel crashes, leaving nothing running. This is what
&lt;em&gt;I&lt;/em&gt; call hard.&lt;/p&gt;
&lt;p&gt;On Linux, there are a couple of hardware interfaces exported to
userspace. I already mentioned &lt;a class="reference external" href="http://www.libusb.org/"&gt;userspace USB&lt;/a&gt;. There is a similar thing to implement USB
&lt;em&gt;devices&lt;/em&gt; in user space, called &lt;a class="reference external" href="http://www.linux-usb.org/gadget"&gt;GadgetFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For others, look inside the kernel documentation, part of the kernel
source, in the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/&lt;/span&gt;&lt;/code&gt; directory. (Usually, the kernel
source is installed in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/usr/src/linux/&lt;/span&gt;&lt;/code&gt;.) Or simply ask Google.&lt;/p&gt;
&lt;p&gt;For example, check out the userspace I2C and SPI interfaces described
in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/i2c/dev-interface&lt;/span&gt;&lt;/code&gt; and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/spi/spidev&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="realtime"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;Realtime&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Well, realtime … what’s that? To put it bluntly, Linux is realtime
capable.&lt;/p&gt;
&lt;p&gt;By default, Linux schedules processes (“scheduled entities”, so to
say - threads as well as processes) &lt;em&gt;in a fair way&lt;/em&gt;. This is, everyone
gets its fair share of CPU resources. As such, there are no guarantees
given as to when a process is scheduled, and whether its deadlines are
met.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;However:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can make any process realtime-scheduled, by calling
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sched_setscheduler()&lt;/span&gt;&lt;/code&gt;. You can make threads realtime-scheduled,
selectively, by creating them with the appropriate attributes (see
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_attr_setschedparam()&lt;/span&gt;&lt;/code&gt;, and read the book :-).&lt;/p&gt;
&lt;p&gt;Realtime-processes are scheduled &lt;em&gt;immediately&lt;/em&gt; when they become
runnable (unless a higher priority process is runnable as well, of
course). And by immediate I mean immediate - and that’s what &lt;em&gt;I&lt;/em&gt; call
realtime. No fairness involved anymore, definitely not nice
anymore. And therefore potentially harmful.&lt;/p&gt;
&lt;p&gt;Basically, there’s two realtime scheduling policies to choose from:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_FIFO&lt;/span&gt;&lt;/code&gt;. The process runs until it puts itself to sleep
(waiting for something to happen), or until it is interrupted by a
process which has an even higher priority.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_RR&lt;/span&gt;&lt;/code&gt;. Processes in the same priority level alternate in a
round robin manner, with very short timeslices. As with
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_FIFO&lt;/span&gt;&lt;/code&gt;, they are interrupted by higher priority processes.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out the man pages, and read the book. No joke. Doing realtime
scheduling is crying for trouble. Even more so if code is involved
where you don’t know 100% exactly what it does. It might go into an
infinite loop, at best. At worst, it will trigger race conditions only
under certain circumstances, or bring up deadlock
situations. Naturally, this kind of errors does not show up during
in-house testing where you are able to inspect and fix them, but
rather months later, at your customer’s site.&lt;/p&gt;
&lt;p&gt;That’s it been for now. I could possibly add a couple more items to
this list, right now. Deployment comes to mind (What’s a firmware
image in Linux? Will I be minimal? Do I use &lt;a class="reference external" href="http://busybox.net/"&gt;BusyBox&lt;/a&gt; and &lt;a class="reference external" href="http://www.uclibc.org/"&gt;uClibc&lt;/a&gt;?),
build issues (Shared libraries? Static? What, how, why?). I could add
another couple more items if I you give me a minute.&lt;/p&gt;
&lt;p&gt;If you have read through this list, you’ll see what I mean: take care
to choose the right mechanisms. Don’t start coding immediately because
there’s no time left in the project. Thinking twice and investigating
will save you from spending even more time later in the project. (But
what am I telling you?)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2011/01/porting-to-linux-there-s-always-a-better-way.html" rel="alternate"/>
    <published>2011-01-07T00:00:00+01:00</published>
  </entry>
</feed>
