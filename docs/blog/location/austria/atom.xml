<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://www.faschingbauer.me</id>
  <title>Jörg Faschingbauer - Posts from Austria</title>
  <updated>2022-07-24T15:39:11.315380+00:00</updated>
  <link href="https://www.faschingbauer.me"/>
  <link href="https://www.faschingbauer.me/blog/location/austria/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.19">ABlog</generator>
  <entry>
    <id>https://www.faschingbauer.me/blog/2010/07/beagleboard-how-to-repair-nand-also-known-as-40w.html</id>
    <title>Beagleboard: How to Repair NAND (also known as 40W)</title>
    <updated>2010-07-30T00:00:00+02:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;section id="beagleboard-how-to-repair-nand-also-known-as-40w"&gt;

&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#basics" id="id1"&gt;Basics&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#getting-x-loader-and-u-boot" id="id2"&gt;Getting X-Loader and U-Boot&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#creating-a-bootable-mmc-sd-card" id="id3"&gt;Creating a Bootable MMC/SD card&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#repairing-the-nand" id="id4"&gt;Repairing the NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#writing-x-loader-to-nand" id="id5"&gt;Writing X-Loader to NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#writing-u-boot-to-nand" id="id6"&gt;Writing U-Boot to NAND&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/aside&gt;
&lt;p&gt;It happened again. Friends of mine have an alias,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;alias faschingbauer=&amp;quot;rm -rf ~&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;in their &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;.bashrc&lt;/span&gt;&lt;/code&gt; for a couple of years now, and now I created a
creative variation thereof.&lt;/p&gt;
&lt;p&gt;I used to have my beagleboard running happily off an SD card, using a
root filesystem which I had updated natively from a &lt;a class="reference external" href="http://mirrors.kernel.org/gentoo/releases/arm/autobuilds/current-stage3/armv4tl-softfloat-linux-gnueabi/"&gt;Gentoo ARM stage3&lt;/a&gt;. This
is decadent, so I prepared a Busybox-only initramfs linked into the
kernel image (cross-built of course, as opposed to the stage3), with
the plans to use this as an alternative boot image residing in NAND
flash.&lt;/p&gt;
&lt;p&gt;It happened to me that, during finding out the correct arguments of
U-Boot’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt; command, I hit the
return key early - expecting that a sole&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;nand erase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;would give me further instructions. U-Boot took it literally though
and erased NAND, just like I told it to. A reboot showed the fatal
consequences. “40W” was the only thing I saw over the serial terminal
(115200/8N1 by the way).&lt;/p&gt;
&lt;p&gt;Here in the remainder I write down how to recover from such a
fauxpas. The internet has a lot of explanations, but none of them is a
walk-through from the beginning to the end. You’ll have to do a couple
of things, and most of the instructions you’ll find don’t explain
much. This is not what I like, so I researched a bit and write the
annotated collected instructions down right here. You might find it
useful - I surely will once I’ll brick my beagle again.&lt;/p&gt;
&lt;section id="basics"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Basics&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The OMAP has a small boot ROM inside. This is the first of the chain
of boot loaders, and it’s where the CPU core jumps to when it’s done
with whatever CPU cores do when they are powered on). The boot ROM is
programmed to load a second stage boot loader (the “X-Loader” as it is
called) into the processor’s SRAM. X-Loader is then responsible for
loading another stage - U-Boot in the Linux case - into the external
DRAM. It’s the latter two stages - X-Loader and U-Boot - that I
faschingbauered away from NAND, and that I’ll recover now.&lt;/p&gt;
&lt;p&gt;They key to all that is the ability of the boot ROM to boot from a
MMC/SD card when the user button is pressed during its operation. We
will prepare one such card, put the boot files on it, and write these
to NAND.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="getting-x-loader-and-u-boot"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Getting X-Loader and U-Boot&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The beagleboard guys wrote up a page with &lt;a class="reference external" href="http://code.google.com/p/beagleboard/wiki/BeagleboardRevC3Validation"&gt;board validation
instructions&lt;/a&gt;. This
is where I have most of the information from. There they give links to
the images that I want. Take care that you select the ones that match
your board revision; the files they use on that page are slightly
seasoned. I have a recent C4, and I found it valuable to have a recent
U-Boot version that enables power on the USB host controller. This was
a change they made from C3 to C4, for example - take care.&lt;/p&gt;
&lt;p&gt;Anyway, &lt;a class="reference external" href="http://www.angstrom-distribution.org/demo/beagleboard/"&gt;Angstrom&lt;/a&gt; have the
most recent stuff. Download X-Loader and U-Boot from there, and
additionally another bootloader stage, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, which is used during
the MMC boot. The filenames change, just browse the directory a choose
something that sounds like &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;x-load.bin.ift&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot*&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO*&lt;/span&gt;&lt;/code&gt;. Save them away for later use. I saved them as
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;x-load.bin.ift&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot.bin&lt;/span&gt;&lt;/code&gt;, and it’s these names that I
refer to later on.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="creating-a-bootable-mmc-sd-card"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Creating a Bootable MMC/SD card&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For basic card configuration I refer you to &lt;a class="reference external" href="http://processors.wiki.ti.com/index.php/MMC_Boot_Format"&gt;a TI maintained page&lt;/a&gt; which is
very concise and to the point, and where there is nothing much left to
say. I followed the instruction using fdisk, and obvoiusly the card
can be read by the boot ROM. There are reports that FAT32 does not
work on some cards, and that selecting FAT16 instead helped. You might
want to try that out in case.&lt;/p&gt;
&lt;p&gt;Once the card is ready and a FAT partition has been created, you mount
that partition and put the files on it as follows.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;First comes &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, as file &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt;, no matter what name you stored
it under on your disk. It is read by the boot ROM, and that one is
very particular that the file is found in the first sectors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You store the U-Boot image as file &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;u-boot.bin&lt;/span&gt;&lt;/code&gt;. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MLO&lt;/span&gt;&lt;/code&gt; expects
it under that name during MMC boot. (If you intend to use a
different U-Boot image for NAND then you store that one under a
different name which you use further down when we write NAND.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The X-Loader is not used during MMC boot, so you can choose any name
you like.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Insert the card into the MMC/SD slot of the beagle, and boot. In case
you erased your NAND only partly and there is still something
meaningful in it, be sure to hold down the user button to force the
boot ROM to boot from the card.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="repairing-the-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Repairing the NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The following is taken from the &lt;a class="reference external" href="http://beagleboard.googlecode.com/files/reset_revc_v3.scr"&gt;reset.scr&lt;/a&gt; U-Boot
script referred to by the &lt;a class="reference external" href="http://code.google.com/p/beagleboard/wiki/BeagleboardRevC3Validation"&gt;beagleboard validation instructions&lt;/a&gt;. I
took care to annotate as much as possible in order to understand the
steps.&lt;/p&gt;
&lt;p&gt;First off, we initialize MMC/SD.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # mmc init&lt;/span&gt;
&lt;span class="go"&gt;mmc1 is available&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To understand where the numbers in the remainder instructions come
from, open the kernel source file
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;arch/arm/mach-omap2/board-omap3beagle.c&lt;/span&gt;&lt;/code&gt;. I’ll refer to that file
in the remainder explanations. Near the top of the file you’ll notice
the partition table; you’ll find it insightful.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="writing-x-loader-to-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Writing X-Loader to NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First, erase the X-Loader partition. According to the partition table,
it starts at offset 0 (where the OMAP’s boot ROM expects it) and is
4*128K=0x80000 bytes long.&lt;/p&gt;
&lt;p&gt;The boot ROM relies on hardware to manage error correction code (ECC),
as described in the &lt;a class="reference external" href="http://download.micron.com/pdf/technotes/nand/tn2916.pdf"&gt;tech note&lt;/a&gt;, so we
select it.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nandecc hw&lt;/span&gt;
&lt;span class="go"&gt;HW ECC selected&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 0 80000&lt;/span&gt;
&lt;span class="go"&gt;NAND erase: device 0 offset 0x0, size 0x80000&lt;/span&gt;
&lt;span class="go"&gt;Erasing at 0x60000 -- 100% complete.&lt;/span&gt;
&lt;span class="go"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;According to the &lt;a class="reference external" href="http://download.micron.com/pdf/technotes/nand/tn2916.pdf"&gt;tech note&lt;/a&gt; again,
the OMAP’s boot ROM takes care of bad blocks (unlikely because an
intermediate bootloader isn’t written to flash that often, but
nevertheless it sounds like a good idea). It checks the first four
blocks of the X-Loader partition for a valid image, so we write the
image into these four blocks. Again, the erase block size is
determined by looking in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;board-omap3beagle.c&lt;/span&gt;&lt;/code&gt; - 128K = 0x20000.&lt;/p&gt;
&lt;p&gt;Read the image into memory, and write it out 4 times, in the first
four erase blocks of the partition.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # fatload mmc 0 80200000 x-load.bin.ift&lt;/span&gt;
&lt;span class="go"&gt;reading x-load.bin.ift&lt;/span&gt;
&lt;span class="go"&gt;20392 bytes read&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 0 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x0, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 20000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x20000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 40000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x40000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 60000 20000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x60000, size 0x20000&lt;/span&gt;
&lt;span class="go"&gt;131072 bytes written: OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="writing-u-boot-to-nand"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Writing U-Boot to NAND&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Can’t find which ECC incarnation the X-Loader uses, software seems to
be the choice (sounds like the do-nothing-and-cross-fingers approach).&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nandecc sw&lt;/span&gt;
&lt;span class="go"&gt;SW ECC selected&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;According to the kernel sources, U-Boot’s partition starts at offset
0x80000 and is 15*128K=0x1e0000 bytes long.&lt;/p&gt;
&lt;p&gt;Erase NAND, load U-Boot from card, write it to the partition.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 80000 1e0000&lt;/span&gt;
&lt;span class="go"&gt;NAND erase: device 0 offset 0x80000, size 0x1e0000&lt;/span&gt;
&lt;span class="go"&gt;Erasing at 0x240000 -- 100% complete.&lt;/span&gt;
&lt;span class="go"&gt;OK&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # fatload mmc 0 80200000 u-boot.bin&lt;/span&gt;
&lt;span class="go"&gt;reading u-boot.bin&lt;/span&gt;
&lt;span class="go"&gt;275928 bytes read&lt;/span&gt;

&lt;span class="go"&gt;OMAP3 beagleboard.org # nand write 80200000 80000 1e0000&lt;/span&gt;
&lt;span class="go"&gt;NAND write: device 0 offset 0x80000, size 0x1e0000&lt;/span&gt;
&lt;span class="go"&gt;1966080 bytes written: OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That’s it. You are now able to boot without the card, up to the U-Boot
prompt.&lt;/p&gt;
&lt;p&gt;Take care when you flash the kernel. In case you don’t know the
correct &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt; parameters, write&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # help nand&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;instead of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nand&lt;/span&gt; &lt;span class="pre"&gt;erase&lt;/span&gt;&lt;/code&gt;. I suggest you type&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;OMAP3 beagleboard.org # nand erase 280000 400000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;just like the kernel source says for the kernel partition.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2010/07/beagleboard-how-to-repair-nand-also-known-as-40w.html" rel="alternate"/>
    <summary>Basics</summary>
    <published>2010-07-30T00:00:00+02:00</published>
  </entry>
  <entry>
    <id>https://www.faschingbauer.me/blog/2011/01/porting-to-linux-there-s-always-a-better-way.html</id>
    <title>Porting to Linux (There’s Always A Better Way)</title>
    <updated>2011-01-07T00:00:00+01:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;section id="porting-to-linux-there-s-always-a-better-way"&gt;

&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#processes-are-threads" id="id1"&gt;Processes are Threads&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#signals-aren-t-messages" id="id2"&gt;Signals Aren’t Messages&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#message-queues-aren-t-message-queues" id="id3"&gt;Message Queues aren’t Message Queues&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#semaphores-and-mutexes" id="id4"&gt;Semaphores and Mutexes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#timers" id="id5"&gt;Timers&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#polling" id="id6"&gt;Polling&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#event-dispatching" id="id7"&gt;Event Dispatching&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#interrupts" id="id8"&gt;Interrupts&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#realtime" id="id9"&gt;Realtime&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/aside&gt;
&lt;p&gt;Over the past months I met a couple of people who are relatively new
to Linux. For one, I’ve been to Germany doing courses on Linux -
naturally the audience in such a course is new to Linux. For another,
I have one and a half customers here in Austria who are mainly doing
microcontroller work and who don’t have a clue of Linux.&lt;/p&gt;
&lt;p&gt;Many of these people have code which they have written and maintained
over a long time, and which has a value. The code runs happily on bare
metal, or on a minimal OS like Segger embOS, Enea OSE, VxWorks, or
even Windows CE. No way rewriting it just because of Linux.&lt;/p&gt;
&lt;p&gt;Well, there’s no need to. It’s just not trivial to choose the right
mechanisms. Linux (and Unix in general) offers so many choices to mess
things up right from the beginning. And it’s quite likely that things
are in fact messed up, which is what I learned from the people I met.&lt;/p&gt;
&lt;p&gt;“Good Old Device Firmware” is quite limited in what it can use.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;It is a statically linked blob of executable code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It operates in a single address space (there’s generally no idea
what an address space is, so there is only one).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It has interrupts hammering on it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If there is an OS, then chances are that there are multiple
processes that are scheduled by the OS. Often processes communicate
by dumping messages into each other’s message queues.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Locking mechanisms. In the presence of interrupts you need to
disable them if need be. If processes are used, there are generally
semaphores available in one or more flavors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s these simple concepts where the confusion starts. For example,
in Linux/Unix a process is probably not what you want - you rather
want a thread instead. When you search for the term “message queue”
you will find &lt;em&gt;several&lt;/em&gt; mechanisms, &lt;em&gt;none of which&lt;/em&gt; are what you
want. You’ll notice sooner or later that you chose the wrong
concept, but it’s maybe too late to revert - causing your Linux port
to fail over the years. (In my opinion it’s never too late to
revert, but that’s a different kind of story.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the remainder I’ll try to give a list of recipes for porting to
Linux. I hope that it will help you speed up the porting project, by
avoiding severe mistakes right at the beginning. The list cannot be
complete - it’s just a blog post after all. But I do hope it will give
you a bigger picture than you already have, and that it provides you
with the starting points for your own research (which you will have to
do unless you want to hire me as a consultant :-).&lt;/p&gt;
&lt;section id="processes-are-threads"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Processes are Threads&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the embedded OS world, you use the word “process” to refer to an
entity that is scheduled by the OS. There is no such thing as separate
address spaces and memory protection in such systems (these OS’s are
initially designed for cheap MMU-less processors).&lt;/p&gt;
&lt;p&gt;So, what people generally want is &lt;em&gt;threads&lt;/em&gt;. &lt;em&gt;Processes&lt;/em&gt; in Unix refer
to address space separation and memory protection, so don’t get misled
only by the term. The Unix way of multithreading is POSIX threads
(pthreads for short). On Linux, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;pthreads&lt;/span&gt;&lt;/code&gt; will tell you
more. Better yet, buy yourself a copy of a &lt;a class="reference external" href="http://oreilly.com/catalog/9781565921153"&gt;PThreads Programming&lt;/a&gt; book. Read that book
twice. Threading has lots of pitfalls, and it is crucial to understand
these. (I have seen people create five threads to solve a simple
data-acquisition-and-network-communication problem where they didn’t
know what a mutex was.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="signals-aren-t-messages"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Signals Aren’t Messages&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Don’t use Unix signals for communication. They have very few in common
with what’s called a &lt;em&gt;signal&lt;/em&gt; in RTOSs. (In the RTOS world, &lt;em&gt;signals&lt;/em&gt;
are often called &lt;em&gt;messages&lt;/em&gt;.)&lt;/p&gt;
&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_signals/slides.html"&gt;&lt;span class="doc"&gt;Slide material: UNIX signals&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_signals/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: UNIX signals&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/aside&gt;
&lt;p&gt;In Unix, signals are commonly used to tear down a process (&lt;em&gt;not&lt;/em&gt; a
thread), giving it a chance to perform proper cleanup before
exit. There are other uses of signals as well, such as notification of
memory protection violation (the dreaded “segmentation fault”) and
other programming errors.&lt;/p&gt;
&lt;p&gt;The problem with signal handling is that signals arrive in a special
context which you probably know as “interrupt context” in your
OS. Consequently, your options are very limited in a signal
handler. You cannot use most of the functions that are available from
the C runtime library!&lt;/p&gt;
&lt;p&gt;If you still feel that you need to use signals, then perform the
following steps.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Think twice. Why do you need signals? There’s probably a better way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Read &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;-s&lt;/span&gt; &lt;span class="pre"&gt;7&lt;/span&gt; &lt;span class="pre"&gt;signal&lt;/span&gt;&lt;/code&gt; for more. &lt;strong&gt;Pay special attention to the
section about async-signal-safe functions&lt;/strong&gt; (note that none of the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_&lt;/span&gt;&lt;/code&gt; functions appears in the list).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Try to defer processing from the signal handler into the regular
course of your application. For example, you can use the “self pipe”
trick (Google sure knows about it.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Forget about asynchronous signal delivery and use one of the``
sigwait``, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigwaitinfo&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigtimedwait&lt;/span&gt;&lt;/code&gt; system calls. This
way you suspend the execution of one thread until a signal is
caught, thus turning signal handling into a &lt;em&gt;synchronous&lt;/em&gt;
approach. You’d have to dedicate an entire thread to signal handling
though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An alternative way of synchronous signal handling is to use the new
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;signalfd&lt;/span&gt;&lt;/code&gt; system call. Its semantics are the same as
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sigwaitinfo&lt;/span&gt;&lt;/code&gt;, only you use a file descriptor as an “event
source”. You can embed this file descriptor among other event
sources in an event driven application, using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt;,
or &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;epoll&lt;/span&gt;&lt;/code&gt;. See below for more.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="message-queues-aren-t-message-queues"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Message Queues aren’t Message Queues&lt;/a&gt;&lt;/h2&gt;
&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_ipc/slides.html"&gt;&lt;span class="doc"&gt;Slide material: POSIX message queues&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_ipc/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: POSIX message queues&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/aside&gt;
&lt;p&gt;Chances are that the threads (err, processes) of your OS communicate
via messages queues over which messages (err, signals) are sent. A
naive Google search (“Linux message queues”) will lead you to POSIX
and System V message queues, both of which are inter process
communication (IPC) mechanisms. This is probably not what you want, as
your messages need not be transferred across different address
spaces. Intra process message queues are normally built on top of
pthread primitives. You can find a sample such implementation &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=pthread/base/message-queue.h"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="semaphores-and-mutexes"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Semaphores and Mutexes&lt;/a&gt;&lt;/h2&gt;
&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;References&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_ipc/slides.html"&gt;&lt;span class="doc"&gt;Slide material: POSIX semaphores&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="../../trainings/material/soup/linux/sysprog/sysprog_ipc/screenplay.html"&gt;&lt;span class="doc"&gt;Demo code: POSIX semaphores&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/aside&gt;
&lt;p&gt;Many of those OSs out there have semaphores as the one and only
synchronisation mechanism. Linux has semaphores - System V and POSIX
style. Again these are probably not what you want. You are likely to
initialize your semaphores with a count of one and use it as a &lt;em&gt;binary
semaphore&lt;/em&gt;. This is what a pthread mutex is for instead.&lt;/p&gt;
&lt;p&gt;See &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;pthread_mutex_init&lt;/span&gt;&lt;/code&gt; for more.&lt;/p&gt;
&lt;p&gt;Confusing note for those porting from Windows: A &lt;em&gt;critical section&lt;/em&gt; is
the region that is protected by a mutex, although a
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CRITICAL_SECTION&lt;/span&gt;&lt;/code&gt; is the closest Windows pendant to a mutex.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="timers"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Timers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Timers are hard, not only on Linux.&lt;/p&gt;
&lt;p&gt;In most embedded OSs, timers expire as interrupts which are then
handled by the application. Sometimes there is the possibility to let
the OS send you a message (err, signal) on timer expiration.&lt;/p&gt;
&lt;p&gt;There are multiple APIs for timers, most of which (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;setitimer&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;timer_create&lt;/span&gt;&lt;/code&gt;) require you to use signals (Unix signals this
time) - see above for the drawbacks to this approach. Unfortunately a
straightforward Google search will lead you to these APIs.&lt;/p&gt;
&lt;p&gt;An alternative is to simply defer the execution of a thread for a
specified amount of time, using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nanosleep&lt;/span&gt;&lt;/code&gt;. Another alternative is
to use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;timerfd_create&lt;/span&gt;&lt;/code&gt; and friends in conjunction with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;
or &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt;, and embed timers into an event driven application. (See
below for event loops based on file descriptors. See &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=linux-events/events/timer.h"&gt;here&lt;/a&gt;
for a sample implementation of such a thing.)&lt;/p&gt;
&lt;p&gt;You can always build your own structures around whatever timer
mechanism and emulate the behavior of your OS on Linux. This might
require quite a bit of understanding of Linux programming, though.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="polling"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Polling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Polling for something to happen is generally the most stupid thing to
do, not only on Linux. The are cases (screwed hardware for example)
where there is no other way, but otherwise there’s always a better
way.&lt;/p&gt;
&lt;p&gt;I have seen people set a flag in one process (err, thread), and poll
for it every millisecond from another thread. I know, a millisecond is
an eternity in nowadays’ processors - but I can imagine that there are
more flags of that sort being polled for, in a moderately complex
program. After all, it’s &lt;em&gt;events&lt;/em&gt; that these flags communicate. Some
OSs have an “event flag” mechanism which tries to achieve exactly
that, albeit a bit more intelligently - for example without the need
for polling, and without losing events through race conditions.&lt;/p&gt;
&lt;p&gt;There’s a big wealth of mechanisms in Linux to communicate events. Use
message queues (see above), for example. Build your own “event flag”
mechanism by using PThreads primitives (but not before you have read
the book).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="event-dispatching"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Event Dispatching&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On Unix, &lt;em&gt;everything is a file&lt;/em&gt;. Entire disks are represented as
files, partitions are, network sockets are, arbitrary devices are (for
example, serial/UART lines). Regular files are, naturally. On Linux,
even timers and Unix signals can be represented as files, as I
mentioned previously. Every open file is represented as a &lt;em&gt;file
descriptor&lt;/em&gt;. File descriptors can be read from and written to, using
the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;read&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;write&lt;/span&gt;&lt;/code&gt; system calls, regardless of their type.&lt;/p&gt;
&lt;p&gt;For people who are new to Unix, this may come as a surprise: you can
read from a serial line as if it were a network connection, and you
can read from a network connection as if it were a regular
file. (Anyone tried that on Windows?)&lt;/p&gt;
&lt;p&gt;This fact alone is something you can take advantage of in your porting
project.&lt;/p&gt;
&lt;p&gt;Now what has this got to do with &lt;em&gt;event dispatching&lt;/em&gt;? Consider the
following types of &lt;em&gt;events&lt;/em&gt; that regularly happen on an OS:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Network connection has data to be read.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Network connection can be written to without blocking (or, “local
TCP buffer just got emptied” or so).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Same with serial IO (open &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/dev/ttyS0&lt;/span&gt;&lt;/code&gt; or so just like a regular
file), as with any kind of stream connection.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A timer has expired.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A signal has arrived.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An arbitrary event happened (check out the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;eventfd&lt;/span&gt;&lt;/code&gt; system call;
I didn’t mention it).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Even USB events are delivered via files. (It’s just a bit more
complicated because USB is a bit more complicated; there’s &lt;a class="reference external" href="http://www.libusb.org/"&gt;libusb&lt;/a&gt; there to handle this.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Most drivers for hardware devices deliver the device interrupts as
events through file descriptors (you open &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/dev/blah&lt;/span&gt;&lt;/code&gt; just like a
regular file), nicely telling you “Hey, I’ve got to tell you
something!”.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is a set of system calls that are used to wait for events on
&lt;em&gt;multiple&lt;/em&gt; file descriptor, namely &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;select&lt;/span&gt;&lt;/code&gt;,`` poll``, and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;epoll&lt;/span&gt;&lt;/code&gt;. Note that these system call put the calling process (err,
thread) to sleep until something happens - the name &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt; has
nothing to do with polling as we know it.&lt;/p&gt;
&lt;p&gt;So, depending on your application, you might find it relatively easy
to use either of these system calls. Build a bit of an infrastructure
around it, like registering and unregistering callbacks, and you will
be able to comfortably use these extremely exciting mechanisms. (Or
take &lt;a class="reference external" href="http://jf-linuxtools.git.sourceforge.net/git/gitweb.cgi?p=jf-linuxtools/jf-linuxtools;a=blob;f=events/dispatcher.h"&gt;my own infrastructure&lt;/a&gt;. Or
take anybody else’s, mine’s not the only - it’s just the best.)&lt;/p&gt;
&lt;p&gt;One last note: look at the desktop environment of your choice. It’s
made up of a hundred or so processes (no, not threads). Under Gnome,
which is what I use, there’s a process called`` gnome-panel``, for
example. Try out &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;strace&lt;/span&gt; &lt;span class="pre"&gt;-p&lt;/span&gt; &lt;span class="pre"&gt;&amp;lt;pid&lt;/span&gt; &lt;span class="pre"&gt;of&lt;/span&gt; &lt;span class="pre"&gt;gnome-panel&amp;gt;;&lt;/span&gt;&lt;/code&gt;, direct the mouse
over the panel, and see what happens: &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;poll&lt;/span&gt;&lt;/code&gt; all over.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="interrupts"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Interrupts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One of the primary goals of an OS is to shield you from
hardware. There a clear separation between &lt;em&gt;user space&lt;/em&gt; and &lt;em&gt;kernel
space&lt;/em&gt;. User space uses system calls to talk to the kernel. No
interrupts in user space. Basta. (Don’t even think about using
signals!)&lt;/p&gt;
&lt;p&gt;If you have hardware that nobody else has, then chances are you will
have to deal with it yourself and write a driver for it. That’s about
the only case where you’ll get in touch with interrupts and have to
learn kernel programming. But this is a completely different story,
and a different world. Definitely fun.&lt;/p&gt;
&lt;p&gt;Nevertheless, I suggest you stay away from kernel programming just
because it is fun. Debugging is much harder there. A buggy user space
program crashes, possibly leaving you with a core dump that you can
examine with a debugger (well, GDB). Everything else will remain
running. A buggy kernel crashes, leaving nothing running. This is what
&lt;em&gt;I&lt;/em&gt; call hard.&lt;/p&gt;
&lt;p&gt;On Linux, there are a couple of hardware interfaces exported to
userspace. I already mentioned &lt;a class="reference external" href="http://www.libusb.org/"&gt;userspace USB&lt;/a&gt;. There is a similar thing to implement USB
&lt;em&gt;devices&lt;/em&gt; in user space, called &lt;a class="reference external" href="http://www.linux-usb.org/gadget"&gt;GadgetFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For others, look inside the kernel documentation, part of the kernel
source, in the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/&lt;/span&gt;&lt;/code&gt; directory. (Usually, the kernel
source is installed in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/usr/src/linux/&lt;/span&gt;&lt;/code&gt;.) Or simply ask Google.&lt;/p&gt;
&lt;p&gt;For example, check out the userspace I2C and SPI interfaces described
in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/i2c/dev-interface&lt;/span&gt;&lt;/code&gt; and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/spi/spidev&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="realtime"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;Realtime&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Well, realtime … what’s that? To put it bluntly, Linux is realtime
capable.&lt;/p&gt;
&lt;p&gt;By default, Linux schedules processes (“scheduled entities”, so to
say - threads as well as processes) &lt;em&gt;in a fair way&lt;/em&gt;. This is, everyone
gets its fair share of CPU resources. As such, there are no guarantees
given as to when a process is scheduled, and whether its deadlines are
met.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;However:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can make any process realtime-scheduled, by calling
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sched_setscheduler()&lt;/span&gt;&lt;/code&gt;. You can make threads realtime-scheduled,
selectively, by creating them with the appropriate attributes (see
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_attr_setschedparam()&lt;/span&gt;&lt;/code&gt;, and read the book :-).&lt;/p&gt;
&lt;p&gt;Realtime-processes are scheduled &lt;em&gt;immediately&lt;/em&gt; when they become
runnable (unless a higher priority process is runnable as well, of
course). And by immediate I mean immediate - and that’s what &lt;em&gt;I&lt;/em&gt; call
realtime. No fairness involved anymore, definitely not nice
anymore. And therefore potentially harmful.&lt;/p&gt;
&lt;p&gt;Basically, there’s two realtime scheduling policies to choose from:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_FIFO&lt;/span&gt;&lt;/code&gt;. The process runs until it puts itself to sleep
(waiting for something to happen), or until it is interrupted by a
process which has an even higher priority.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_RR&lt;/span&gt;&lt;/code&gt;. Processes in the same priority level alternate in a
round robin manner, with very short timeslices. As with
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_FIFO&lt;/span&gt;&lt;/code&gt;, they are interrupted by higher priority processes.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out the man pages, and read the book. No joke. Doing realtime
scheduling is crying for trouble. Even more so if code is involved
where you don’t know 100% exactly what it does. It might go into an
infinite loop, at best. At worst, it will trigger race conditions only
under certain circumstances, or bring up deadlock
situations. Naturally, this kind of errors does not show up during
in-house testing where you are able to inspect and fix them, but
rather months later, at your customer’s site.&lt;/p&gt;
&lt;p&gt;That’s it been for now. I could possibly add a couple more items to
this list, right now. Deployment comes to mind (What’s a firmware
image in Linux? Will I be minimal? Do I use &lt;a class="reference external" href="http://busybox.net/"&gt;BusyBox&lt;/a&gt; and &lt;a class="reference external" href="http://www.uclibc.org/"&gt;uClibc&lt;/a&gt;?),
build issues (Shared libraries? Static? What, how, why?). I could add
another couple more items if I you give me a minute.&lt;/p&gt;
&lt;p&gt;If you have read through this list, you’ll see what I mean: take care
to choose the right mechanisms. Don’t start coding immediately because
there’s no time left in the project. Thinking twice and investigating
will save you from spending even more time later in the project. (But
what am I telling you?)&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2011/01/porting-to-linux-there-s-always-a-better-way.html" rel="alternate"/>
    <summary>Processes are Threads</summary>
    <published>2011-01-07T00:00:00+01:00</published>
  </entry>
  <entry>
    <id>https://www.faschingbauer.me/blog/2011/01/saving-solid-state-disk-life--gentoo.html</id>
    <title>Saving Solid State Disk Life (Gentoo)</title>
    <updated>2011-01-11T00:00:00+01:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;section id="saving-solid-state-disk-life-gentoo"&gt;

&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#rant" id="id1"&gt;Rant&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#no-swap" id="id2"&gt;No Swap&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#tmpfs-instances-here-and-there" id="id3"&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt; instances here and there&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#syslog-var-log-messages" id="id4"&gt;Syslog, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#kernel-i-o-scheduler" id="id5"&gt;Kernel I/O Scheduler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#use-ram-for-the-kernel-build" id="id6"&gt;Use RAM for the Kernel Build&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#things-that-are-left" id="id7"&gt;Things that are left&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/aside&gt;
&lt;section id="rant"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Rant&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Today’s mechanical disks are optimized for writing one Excel sheet a
day it seems. Holding the browser cache significantly decreases
lifetime of a disk. Developing source code and compiling entire trees
multiple times a day, plus updating a Gentoo install once a week is a
recipe to kill a disk.&lt;/p&gt;
&lt;p&gt;So I killed three (&lt;em&gt;three&lt;/em&gt;) mechanical disks last year.&lt;/p&gt;
&lt;p&gt;I pretty much depend on these disks as I don’t like moving back and
forth between the number one and the spare laptop three times in a
row. (I’m self employed, and the volume of such undertakings is
&lt;em&gt;indirectly&lt;/em&gt; proportional to the flow of money into my pocket.)&lt;/p&gt;
&lt;p&gt;Which is why I decided to purchase a solid state disk. My choice was a
Corsair Force Series 120. It has pretty good reviews on the Internet,
especially for having received a firmware overhaul that reserves less
space for the wear leveling management, thus leaving more of the space
to the user.&lt;/p&gt;
&lt;p&gt;I should have known better. Fresh firmware is not cool; it has never
been. During the Gentoo install (no, I compile to RAM now, and &lt;em&gt;not&lt;/em&gt;
to disk) there is a point where I reboot to switch away from the
Ubuntu LiveCD boot, into the fresh Gentoo system. That was the time
where the SSD has vanished - it was gone! No mention of it, nowhere.&lt;/p&gt;
&lt;p&gt;Support request on the Corsair website, sent disk to their returns
department in the Netherlands. After a few days received an email
saying it would last unusually long as they had to cope with an
unusual volume of returns. Looks like I am not alone. I bet they
themselves write those SSD reviews you find on the Internet.&lt;/p&gt;
&lt;p&gt;Anyway - after two more weeks of aggressive spare laptop harddisk
treatment I am now the proud owner of a 120G SSD with even fresher
firmware, and have set it up to a point where I can work with it. I
describe below what I did to extend its life, and what’s still to be
done. If you have recipes that target the same, please let me know.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="no-swap"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;No Swap&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have plenty of RAM (4G), and I run Linux, so there shouldn’t be any
need to swap. Unfortunately hibernating does not work without swap
(the kernel uses swap to write the state into). I configured one
partition for the purpose of hibernating, which I don’t configure in
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/fstab&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I usually suspend to RAM when at home, and when I move to the living
room or board a train to Germany then I hibernate like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;sync &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; swapon /dev/sda1 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; disk &amp;gt; /sys/power/state &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; swapoff /dev/sda1
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="tmpfs-instances-here-and-there"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt; instances here and there&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The overall rule is, “You can read from a SSD as often as you want,
but don’t write to it.”. With this in mind, I immediately identify two
places where I write continuously, and which can be mitigated easily.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/tmp&lt;/span&gt;&lt;/code&gt; is used by programs to hold small amounts of temporary data
which is perfect for a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt; instance.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/tmp/portage&lt;/span&gt;&lt;/code&gt; is used by portage (Gentoo’s package installer)
to compile the packages before installation. I have plenty of RAM
(4G), so why not use that for compilation. See below for an
openoffice rant.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All that needs to be done is add two entries to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/fstab&lt;/span&gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;portage-tmpfs /var/tmp/portage tmpfs rw 0 0&lt;/span&gt;
&lt;span class="go"&gt;tmp-tmpfs     /tmp             tmpfs rw 0 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;You might want to set &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TMPDIR=/tmp&lt;/span&gt;&lt;/code&gt; explicitly, to have GCC write
its temporary files there instead of in its current working
directory. Create a dedicated file in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/env.d&lt;/span&gt;&lt;/code&gt;, and call
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;env-update&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I could limit the space on these by writing &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;rw,size=500m&lt;/span&gt;&lt;/code&gt; for
example. Anyway, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt; limits its size to be half the memory as a
default, so in my case this is 2G in each instance.&lt;/p&gt;
&lt;p&gt;I hit the limit on the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/tmp/portage&lt;/span&gt;&lt;/code&gt; instance really soon, when
I tried to install openoffice. That piece of crap requires 6G of disk
space for compilation! Ok, I take it I have to make an exception which
reads like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;&lt;span class="c1"&gt;# (plug my USB throwaway 1TB disk)&lt;/span&gt;
&lt;span class="gp"&gt;# &lt;/span&gt;mount /dev/sdc1 /mnt/disk
&lt;span class="gp"&gt;# &lt;/span&gt;mkdir /mnt/disk/tmp-portage
&lt;span class="gp"&gt;# &lt;/span&gt;mount --bind /mnt/disk/tmp-portage /var/tmp/portage
&lt;span class="gp"&gt;# &lt;/span&gt;emerge openoffice
&lt;span class="gp"&gt;# &lt;/span&gt;&lt;span class="c1"&gt;# (wait a day or two)&lt;/span&gt;
&lt;span class="gp"&gt;# &lt;/span&gt;rm -rf /mnt/disk/tmp-portage
&lt;span class="gp"&gt;# &lt;/span&gt;umount /var/tmp/portage
&lt;span class="gp"&gt;# &lt;/span&gt;umount /mnt/disk
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="syslog-var-log-messages"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Syslog, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I like to watch &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt;, and in fact I have &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tail&lt;/span&gt; &lt;span class="pre"&gt;-f&lt;/span&gt;
&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt; runnung in a dedicated terminal. I usually have no
interest in keeping the logfile; the last time the kernel crashed was
when I had put an offending debug message into &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;i2c-dev.c&lt;/span&gt;&lt;/code&gt; to trap a
userspace error I had made. And that was on the Beagleboard.&lt;/p&gt;
&lt;p&gt;So, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt; is another candidate for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt;. Complications:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Restrict the file in size, which is best done by &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;logrotate&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cannot use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log&lt;/span&gt;&lt;/code&gt; as mountpoint for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt;, as there’s
more in that directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="mountpoint-for-messages"&gt;
&lt;h3&gt;Mountpoint for messages&lt;/h3&gt;
&lt;p&gt;I create a dedicated directory as a mountpoint, moving the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;messages&lt;/span&gt;&lt;/code&gt; one level deeper,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;rm /var/log/messages
&lt;span class="gp"&gt;# &lt;/span&gt;mkdir /var/log/messages
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mount a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tmpfs&lt;/span&gt;&lt;/code&gt; there, using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/fstab&lt;/span&gt;&lt;/code&gt;,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;messages-tmp  /var/log/messages tmpfs rw 0 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;At this point you use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mount&lt;/span&gt; &lt;span class="pre"&gt;-a&lt;/span&gt;&lt;/code&gt; to immediately create the
mount. Next, tell &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;syslog-ng&lt;/span&gt;&lt;/code&gt; about it. In
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/syslog-ng/syslog-ng.conf&lt;/span&gt;&lt;/code&gt; write,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;...
&lt;span class="go"&gt;destination messages { file(&amp;quot;/var/log/messages/messages&amp;quot;); };&lt;/span&gt;
&lt;span class="gp"&gt;# &lt;/span&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="logrotate"&gt;
&lt;h3&gt;Logrotate&lt;/h3&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;emerge app-admin/logrotate
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Make sure &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cron&lt;/span&gt;&lt;/code&gt; is running (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;rc-status|grep&lt;/span&gt; &lt;span class="pre"&gt;cron&lt;/span&gt;&lt;/code&gt;, he runs &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;logrotate&lt;/span&gt;&lt;/code&gt;). &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;syslog-ng&lt;/span&gt;&lt;/code&gt; already comes with a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;logrotate&lt;/span&gt;&lt;/code&gt; configuration file, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/logrotate.d/syslog-ng&lt;/span&gt;&lt;/code&gt;. Tune this to our needs (rotate the file when its size exceeds 20M, keeping one compressed copy).&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;/var/log/messages/messages {&lt;/span&gt;
&lt;span class="go"&gt;     compress&lt;/span&gt;
&lt;span class="go"&gt;     compresscmd /bin/bzip2&lt;/span&gt;
&lt;span class="go"&gt;     compressoptions -9&lt;/span&gt;
&lt;span class="go"&gt;     compressext .bz2&lt;/span&gt;
&lt;span class="go"&gt;     size 20M&lt;/span&gt;
&lt;span class="go"&gt;     rotate 1&lt;/span&gt;
&lt;span class="go"&gt;     missingok&lt;/span&gt;
&lt;span class="go"&gt;     sharedscripts&lt;/span&gt;
&lt;span class="go"&gt;     postrotate&lt;/span&gt;
&lt;span class="go"&gt;         /etc/init.d/syslog-ng reload &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || true&lt;/span&gt;
&lt;span class="go"&gt;     endscript&lt;/span&gt;
&lt;span class="go"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="kernel-i-o-scheduler"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Kernel I/O Scheduler&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The kernel uses an algorithm called an I/O scheduler to optimize disk access. It does this by collecting read and write requests at adjacent disk locations. This is not necessary with SSDs as there are no disks and no heads. I switch off the scheduler for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sda&lt;/span&gt;&lt;/code&gt; (which is the SSD), and keep the default scheduler (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cfq&lt;/span&gt;&lt;/code&gt;) for USB disks I use to plug on occasion (for example if there’s an openoffice update).&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;In &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/etc/conf.d/local.start&lt;/span&gt;&lt;/code&gt; I write,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; noop &amp;gt; /sys/block/sda/queue/scheduler
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="use-ram-for-the-kernel-build"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;Use RAM for the Kernel Build&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am a big believer in out-of-source builds. The kernel build system
is also capable of it, and I use to build the kernel in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/tmp&lt;/span&gt;&lt;/code&gt; like
so.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;# &lt;/span&gt;mkdir /tmp/kernel-build
&lt;span class="gp"&gt;# &lt;/span&gt;cp /boot/linux-2.6.36-gentoo-r5/.config /tmp/kernel-build
&lt;span class="gp"&gt;# &lt;/span&gt;make -C /usr/src/linux &lt;span class="nv"&gt;O&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/tmp/kernel-build oldconfig
&lt;span class="gp"&gt;# &lt;/span&gt;make -C /usr/src/linux &lt;span class="nv"&gt;O&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/tmp/kernel-build menuconfig
&lt;span class="gp"&gt;# &lt;/span&gt;make -C /usr/src/linux &lt;span class="nv"&gt;O&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/tmp/kernel-build all
&lt;span class="gp"&gt;# &lt;/span&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Don’t forget to save away the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;.config&lt;/span&gt;&lt;/code&gt; file, as it will be gone
after a reboot. I use to store it along with the kernel image in
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/boot/linux-2.6.36-gentoo-r5&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="things-that-are-left"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;Things that are left&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are a couple of things that still need work.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Xorg appears to have a hardcoded log location; I didn’t find a
config option to have it write its &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Xorg.0.log&lt;/span&gt;&lt;/code&gt; in a directory
other than &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There appears to be bug in portage; it does not respect the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;EMERGE_LOG_DIR&lt;/span&gt;&lt;/code&gt; variable. Otherwise, I could redirect the files
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;emerge.log&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;emerge-fetch.log&lt;/span&gt;&lt;/code&gt; out of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log&lt;/span&gt;&lt;/code&gt;, just
like I do with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/var/log/messages&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The fact remains that I build my own projects on disk. I have to
solve that somehow; I am thinking of using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;aufs&lt;/span&gt;&lt;/code&gt; or
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unionfs-fuse&lt;/span&gt;&lt;/code&gt; to partly persist those. Some scripting around it
maybe, to persist those parts of the build which are currently in
ram. But this is another story, maybe I’ll write about it when I
know what I want.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2011/01/saving-solid-state-disk-life--gentoo.html" rel="alternate"/>
    <summary>Rant</summary>
    <published>2011-01-11T00:00:00+01:00</published>
  </entry>
  <entry>
    <id>https://www.faschingbauer.me/blog/2012/04/Why-ps-sucks.html</id>
    <title>“Why ps Sucks” or “Counting Memory Consumption”</title>
    <updated>2012-04-03T00:00:00+02:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;section id="why-ps-sucks-or-counting-memory-consumption"&gt;

&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#process-stack-management" id="id2"&gt;Process Stack Management&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#conclusion" id="id3"&gt;Conclusion&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#thread-pthread-stack-management" id="id4"&gt;Thread (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread&lt;/span&gt;&lt;/code&gt;) Stack Management&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-1-100-default-threads-eating-no-stack" id="id5"&gt;Experiment #1: 100 default threads, eating no stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-2-100-default-threads-eating-up-stack" id="id6"&gt;Experiment #2: 100 default threads, eating up stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-3-100-threads-with-limited-stack" id="id7"&gt;Experiment #3: 100 threads with limited stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-4-more-threads-than-my-system-could-take-eat-no-stack" id="id8"&gt;Experiment #4: more threads than my system could take (eat no stack)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-5-more-threads-than-my-system-could-take-eat-stack" id="id9"&gt;Experiment #5: more threads than my system could take (eat stack)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#how-does-this-work" id="id10"&gt;How does this work?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#id1" id="id11"&gt;Conclusion&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#realtime-is-different" id="id12"&gt;Realtime is different&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/aside&gt;
&lt;p&gt;Recently, I held a course on select topics around embedded Linux, at a
company in Zürich. The audience was pretty cool - they had ported
their appliance from a hardcore embedded OS to Linux a couple of years
ago. They are doing quite well nowadays. A bit too much realtime
attitude maybe (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_RR&lt;/span&gt;&lt;/code&gt; threads all over), but things appear to
work.&lt;/p&gt;
&lt;p&gt;On day 1, when we began to dive into multithreading (an inevitable
topic nowadays), an interesting question came up. “We have 70 threads
running, give each thread a stack size of 1 MB, and thus consume 70 MB
for the stacks alone. Add heap and program, and a couple of other
programs. Given a total memory of 128 MB, we’re soon dead.”&lt;/p&gt;
&lt;p&gt;“Can’t be!” was my first attempt to clear up the situation. The
attempt was rejected. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; output sure didn’t help a lot either. An
explanation of virtual memory (part of the course anyway) was the
second attempt, but still not bullet proof. More evidence
needed. Fortunately day 1 was over at this point, and I was left with
some overnight homework. During night I was able to come up with a
plausible screenplay in example form, to give a basic understanding of
how Linux does memory management. And that screenplay even backs my
instinctive “Can’t be!” defense. It’s these late night experiments
that I’m trying to share in this post.&lt;/p&gt;
&lt;section id="process-stack-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Process Stack Management&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First off, lets keep out multithreading and examine the stack behavior
of a plain old process. The following program grows the stack up to a
user supplied limit. Normally stack growth is done by calling
functions on top of other functions on top of … . This is a bit
cumbersome to program when you want to grow the stack up to a given
size, so I use a handy little tricky function, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca&lt;/span&gt;&lt;/code&gt;, to allocate
stack space. It does essentially the same - grow stack -, and I don’t
have to count stack addresses. Additionally, to be sure that the stack
is actually used (“dirty”), I set the allocated bytes to zero,
explicitly.&lt;/p&gt;
&lt;div class="highlight-c notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;alloca.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* stack-allocated bytes */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s stack-growth&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PID: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;done&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Compile like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;gcc -o process-stack process-stack.c
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So, lets start with a small stack,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 24299&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Examine the various size attributes of the process, using the cool
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;-o&lt;/span&gt;&lt;/code&gt; option to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;24299&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  3944   986   188   320&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, that’s really small. What do the columns mean? I sure don’t know -
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; is not very exact in its descriptions. Here’s my
interpretation.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;VSZ&lt;/span&gt;&lt;/code&gt; is the entire “virtual size”, whatever this means, in K. We
sure can’t attribute read-only mappings of shared libraries like
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;glibc&lt;/span&gt;&lt;/code&gt; to the process’s memory consumption - &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;glibc&lt;/span&gt;&lt;/code&gt;’s code is
shared between all processes that use it, and is resident in memory
&lt;em&gt;only once for all processes&lt;/em&gt;. Virtual memory basic usage, so to
say. The VSZ column tells us nothing about memory usage, I
presume.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SZ&lt;/span&gt;&lt;/code&gt; is the size of the “core image” of the process, in
pages. Whatever that is. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells me something about code,
stack, data. The page size on my system is 4K, which leads me to
assume that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SZ&lt;/span&gt;&lt;/code&gt; roughly equals &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;VSZ&lt;/span&gt;&lt;/code&gt;. I’m not interested in
code, so forget about this one either.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; looks promising, from what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells me. “Amount of
swap that would be required if the process were to dirty all
writable pages and then be swapped out”. Allocated stack is dirtied
by definition, so this appears to be a good measure of stack
consumption - at least for our little stack-eater program. I assume
that the size unit is 1K because &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; is a little less than
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; (described below).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt;, “Resident set size”, in 1K units. This is the amount of
&lt;em&gt;non-swapped&lt;/em&gt; memory the process is currently using. This does
include in-core code pages as well, so this value is of limited
use. Furthermore, I consider &lt;em&gt;swapped&lt;/em&gt; memory relevant as well, and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; doesn’t count that.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; according to the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; column, allocating 10 bytes
on the stack leads me to a program that consumes 188K of main
memory. I suspect that this is the size of a minimal program anyway,
even if it does not consume anything.&lt;/p&gt;
&lt;p&gt;Anyway, let’s proceed with our tests and eat a million bytes stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;1000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 24908&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;24908&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  4800  1200  1044  1376&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, the columns have grown within reason and reflect what we
did. Next, we become a bit greedy and want ten million bytes&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;10000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 24960&lt;/span&gt;
&lt;span class="go"&gt;Segmentation fault&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We’ve hit the stack size limit 8MB which places a barrier against
greedy people,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -s
&lt;span class="go"&gt;8192&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Eight million bytes is ok, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; gives no surprise.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 25018&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;25018&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt; 11632  2908  7876  8236&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;section id="conclusion"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Conclusion&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The stack of a process starts small and grows on demand, magically, up
to a limit. The logic is built in to the OS, which makes sense because
it does not make sense to have a process without a stack. The
operating system takes care of extending the stack by allocating
memory under the hood, and we don’t want to bother.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="thread-pthread-stack-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Thread (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread&lt;/span&gt;&lt;/code&gt;) Stack Management&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now for thread stacks. The story is a bit different here - POSIX
threads have an attribute “stack size”. It can be explicitly set using
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_attr_setstacksize()&lt;/span&gt;&lt;/code&gt;, or left default which is 2MB or the
value of the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RLIMIT_STACK&lt;/span&gt;&lt;/code&gt; resource limit if that is set (see &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt;
&lt;span class="pre"&gt;pthread_create&lt;/span&gt;&lt;/code&gt;). A test program similar to the one above, but with
threads instead, would thus have the following parameters:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nthreads&lt;/span&gt;&lt;/code&gt;, the number of threads to create&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;stack-limit&lt;/span&gt;&lt;/code&gt;, the &lt;em&gt;stack size&lt;/em&gt; attribute of each thread. We call
it “limit” and not “size” as it will turn out that it is exactly
that.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;stack-growth&lt;/span&gt;&lt;/code&gt;, the number of bytes to allocate on the stack. This
is done using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca()&lt;/span&gt;&lt;/code&gt;, just like the process test program
does.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The program creates &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nthreads&lt;/span&gt;&lt;/code&gt; threads. Each thread acts like the
process example program above - allocate stack using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca()&lt;/span&gt;&lt;/code&gt; and
then shut up and sit. It looks as follows.&lt;/p&gt;
&lt;div class="highlight-c notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* stack-allocated bytes */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;thread_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s nthreads stack-limit stack-growth&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PID: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_setstacksize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;set stack size to %ld: %s (%d)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strerror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thread_func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed after %d threads&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Compile like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;gcc -pthread -o thread-stack thread-stack.c
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;section id="experiment-1-100-default-threads-eating-no-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Experiment #1: 100 default threads, eating no stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let’s create a hundred threads with default stack size, each eating
100 bytes of stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;
&lt;span class="go"&gt;PID: 31524&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;31524&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;825840 206460 819936 1404&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So what? &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; reports the process as consuming over 800MB of
memory. According to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;’s description, “if it were to dirty all
writeable pages”, then this would be the amount of swap required. A
little calculation shows that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; is approximately 100 times
8MB. 8MB is the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RLIMIT_STACK&lt;/span&gt;&lt;/code&gt; resource limit that is configured on
my machine (check with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ulimit&lt;/span&gt; &lt;span class="pre"&gt;-s&lt;/span&gt;&lt;/code&gt;), and we started 100 threads. So
it appears that the process has allocated &lt;strong&gt;800MB worth of physical
memory pages, although only 100 bytes of each stack have been eaten&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;“Can’t be!” is what I said.&lt;/p&gt;
&lt;p&gt;Of course the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; field reports much less - but &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does not
report swapped memory, so we cannot count on it very much.&lt;/p&gt;
&lt;p&gt;But anyway - let’s accept the alleged waste of memory for a moment and
carry on with the experiments.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-2-100-default-threads-eating-up-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;Experiment #2: 100 default threads, eating up stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first experiment created 100 threads with default stack size 8MB,
and consumed almost nothing of the stacks. Lets eat up the stacks and
see what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports this time.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 771&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;771&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;825840 206460 819936 766604&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Aha. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; hasn’t changed, but &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; reports much more than the
last time around. Apparently &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does have value - at least on my
system where no swap is configured.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-3-100-threads-with-limited-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Experiment #3: 100 threads with limited stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;See what effect a stack limit has.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;4096&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 1026&lt;/span&gt;
&lt;span class="go"&gt;set stack size to 4096: Invalid argument (22)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, we cannot limit the stack to only a single page. We don’t insist
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PTHREAD_STACK_MIN&lt;/span&gt;&lt;/code&gt; is 4 pages anyway), so lets increase stack size
and see what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells us.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;16384&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 1125&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;1125&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  7840  1960  1936  1404&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Well. 100 minimal threads lead to a process that consumes minimal
resources. Fine.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; Provided that we carefully limit our threads’ stacks,
we don’t eat up too much memory.&lt;/p&gt;
&lt;p&gt;Can’t be! Do I really have to fine-tune my stacks and risk stack
overflows and hard to find bugs?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-4-more-threads-than-my-system-could-take-eat-no-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;Experiment #4: more threads than my system could take (eat no stack)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now a definitive take: I have 64 bit address space, 4G of physical
RAM, and no swap configured. So, I could create no more than 512
threads with 8MB stack size each - 512*8MB == 4G. Let’s try that out
and create 513 threads. Each of the threads eats only 10 bytes of its
stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;513&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 2212&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;2212&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;4210920 1052730 4205016 4576&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Works! &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports more &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; than my system can take. What did
they say about &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt;, “&lt;em&gt;if it were to dirty all writeable pages&lt;/em&gt;”?
This suggests that pages totalling 4205016 bytes have been allocated
to the process. I don’t have that many pages, so it seems like I
misunderstand. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; seems to be definitive about the size.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-5-more-threads-than-my-system-could-take-eat-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;Experiment #5: more threads than my system could take (eat stack)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Obviously the system permits its processes to “overcommit”
memory. Others still get their share. Nobody complained during
experiment #4, music kept playing without noticeable stutter. Now lets
actually use the stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;513&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 4353&lt;/span&gt;
&lt;span class="go"&gt;Killed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, that’s what I’d expect. Until the process was killed, the Red Hot
Chili Peppers had become overly funky (audio glitches all over), and
the Adobe Flash Plugin had crashed (Good Riddance). Less threads …&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;400&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 8462&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;8462&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;3284640 821160 3278736 3064580&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It looks like I can create a bit more than 400 threads which eat up
their 8MB stacks. Not bad, as these numbers lie well within the
physical constraints of my machine.&lt;/p&gt;
&lt;p&gt;So, when I am able to create 400 threads which eat up their 8MB
(default) stacks, then I should be able to create about 800 threads
which eat up half of their 8MB stacks, right?&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;800&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;4000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 11338&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That was ok, try 900 threads …&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;900&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;4000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 12156&lt;/span&gt;
&lt;span class="go"&gt;Killed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Conclusion: We don’t have to fine-tune stacks!&lt;/strong&gt; Just as with the
process example, thread stacks are allocated &lt;em&gt;on demand&lt;/em&gt;, up to a
limit. A valid reason to decrease the stack size limit to a lower
value than the default is to keep it from eating up more memory than
expected. Stacks don’t shrink, so if I inadvertently - only once -
call a function that uses a 3MB automatic variable, I have a memory
leak.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="how-does-this-work"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;How does this work?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First, have a look at the way the Pthread library sets up a
thread. This is best done with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;strace&lt;/span&gt;&lt;/code&gt;. The system call to watch
out for is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt; is used to create both processes
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;fork()&lt;/span&gt;&lt;/code&gt; is implemented in terms of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;) and threads, just
with different kinds of flags.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;strace -f ./thread-stack &lt;span class="m"&gt;30&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The output is rather long, I have tried to keep out the noise and show
only the interesting stuff. We have told the program to create 30
threads with default stack size 8MB. Hence we see 30 blocks like this
one,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;[pid 14386] clone(child_stack=0x7f5813f22ff0,&lt;/span&gt;
&lt;span class="go"&gt;          flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHA...) = 14413&lt;/span&gt;
&lt;span class="go"&gt;[pid 14386] mmap(NULL, 8392704, PROT_READ|PROT_WRITE,&lt;/span&gt;
&lt;span class="go"&gt;          MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fd14f9af000&lt;/span&gt;
&lt;span class="go"&gt;[pid 14386] mprotect(0x7fd14f1ae000, 4096, PROT_NONE) = 0&lt;/span&gt;
&lt;span class="go"&gt;[pid 14413] pause( &amp;amp;lt;unfinished ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;What we see here is,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The main thread, 14386, creates a thread 14413 using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;
with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CLONE_VM&lt;/span&gt;&lt;/code&gt; flag and a few other flags. The kernel creates
a new “process” which shares the parent’s address space - which is
basically the definition of a thread.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The main thread allocates the requested stack using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mmap()&lt;/span&gt;&lt;/code&gt;. This
creates a &lt;em&gt;memory mapping&lt;/em&gt; - only a placeholder for memory, to be
allocated with pages &lt;em&gt;on demand&lt;/em&gt;, as memory is accessed. The memory
is accessible in the caller’s address space at address
0x7fd14f9af000, extending for 8392704 bytes. &lt;strong&gt;Note&lt;/strong&gt; that this is
4096 bytes more than the 8MB stack size.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The main thread protects 4096 bytes at the top of the stack (which
it has allocated in addition to what was requested) with
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PROT_NONE&lt;/span&gt;&lt;/code&gt;. Meaning that access to this part of the mapping will
lead to a segmentation fault. This is cheap and easy stack overflow
protection.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The created thread 14413 then calls &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pause()&lt;/span&gt;&lt;/code&gt;, which is what the
threads in our test program do after they have eaten their stack.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once mappings have been created, we can inspect them in the process’s
directory in the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem:&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;cat /proc/14386/maps
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1af000-7fd14f9af000 rw-p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;7fd14f9af000-7fd14f9b0000 ---p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;These two lines are the result of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mmap&lt;/span&gt; &lt;span class="pre"&gt;(PROT_READ|PROT_WRITE)&lt;/span&gt;&lt;/code&gt;,
followed by &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mprotect&lt;/span&gt; &lt;span class="pre"&gt;(PROT_NONE)&lt;/span&gt;&lt;/code&gt; of the topmost page. The first
line is the 8MB stack which has read/write access, the second line is
the “red” stack overflow protection page, without any access bits
set. Still this doesn’t show any details of the mapping; these can be
seen from another pseudo-file in the process’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; directory. (I
can imagine that the presence of a second file with redundant
information has historical reasons.)&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;cat /proc/14386/smaps
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1ae000-7fd14f1af000 ---p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;Size:                  4 kB&lt;/span&gt;
&lt;span class="go"&gt;Rss:                   0 kB&lt;/span&gt;
&lt;span class="go"&gt;Pss:                   0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Clean:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Dirty:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Clean:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Dirty:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Referenced:            0 kB&lt;/span&gt;
&lt;span class="go"&gt;Anonymous:             0 kB&lt;/span&gt;
&lt;span class="go"&gt;AnonHugePages:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Swap:                  0 kB&lt;/span&gt;
&lt;span class="go"&gt;KernelPageSize:        4 kB&lt;/span&gt;
&lt;span class="go"&gt;MMUPageSize:           4 kB&lt;/span&gt;
&lt;span class="go"&gt;Locked:                0 kB&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1af000-7fd14f9af000 rw-p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;Size:               8192 kB&lt;/span&gt;
&lt;span class="go"&gt;Rss:                   8 kB&lt;/span&gt;
&lt;span class="go"&gt;Pss:                   8 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Clean:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Dirty:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Clean:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Dirty:         8 kB&lt;/span&gt;
&lt;span class="go"&gt;Referenced:            8 kB&lt;/span&gt;
&lt;span class="go"&gt;Anonymous:             8 kB&lt;/span&gt;
&lt;span class="go"&gt;AnonHugePages:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Swap:                  0 kB&lt;/span&gt;
&lt;span class="go"&gt;KernelPageSize:        4 kB&lt;/span&gt;
&lt;span class="go"&gt;MMUPageSize:           4 kB&lt;/span&gt;
&lt;span class="go"&gt;Locked:                0 kB&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we see the same two mappings, but with additional information. It
is exactly this information that we are missing from &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first mapping represents the red page. Its size is 4K. No &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt;,
no nothing else. Pretty shallow, not backed by any physical memory.&lt;/p&gt;
&lt;p&gt;The second mapping is the stack itself, with the following
information:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The mapping’s extent (Size) is 8MB which is no surprise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;8K is currently resident. Again, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does not help much as the
number is swamped by swap.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The most important information is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Private_Dirty&lt;/span&gt;&lt;/code&gt; - the number of
bytes that are “dirty” and thus have to be allocated and attributed
to the process. “Private” means that the memory is not shared with
any other process (stacks are not shared of course), and thus the
memory is attributed &lt;em&gt;only to the process&lt;/em&gt;. Here we can see that,
although the size of the mapping is 8MB, &lt;strong&gt;only 8K are actually
used&lt;/strong&gt;. As it happens the same amount is also resident, but again,
this need not be.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Conclusion&lt;/a&gt;&lt;/h2&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: INFO/1 (&lt;span class="docutils literal"&gt;/home/jfasch/work/jfasch-home/blog/2012/04/Why-ps-sucks.rst&lt;/span&gt;, line 586); &lt;em&gt;&lt;a href="#id1"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Duplicate implicit target name: “conclusion”.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;There’s no reason to panic when &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports large numbers. It’s
just not easy to find out how much memory a process actually
consumes. By understanding the information the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem
provides, you at least have the chance to find out what you need.&lt;/p&gt;
&lt;p&gt;What is most important to understand is the &lt;em&gt;on demand&lt;/em&gt; nature of
memory allocation. That the &lt;em&gt;size&lt;/em&gt; of a memory mapping is definitely
meaningless, and that mappings are “filled” with memory pages as
memory is actually accessed. Stacks are actually nothing but mappings
as we saw above. The same principle applies to the heap
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc/PID/maps&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc/PID/smaps&lt;/span&gt;&lt;/code&gt; actually report a mapping
named “heap”), program code (a mapping which is shared between many
processes and which is read-only), global read-only and read-write
data (the latter is copied on-demand and only then attributed to the
modifying process). There are many other usages of memory mappings -
dig through the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem to find
out. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/filesystems/proc.txt&lt;/span&gt;&lt;/code&gt; from the Linux kernel
source code gives a thorough explanation of the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;smaps&lt;/span&gt;&lt;/code&gt; entries, and
much more.&lt;/p&gt;
&lt;section id="realtime-is-different"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Realtime is different&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;On demand&lt;/em&gt; memory allocation is counter productive in a realtime
scenario as it can delay execution substantially. To overcome this
situation, one needs to make sure memory is actually available
beforehand. No way &lt;em&gt;having to wait&lt;/em&gt; for stack memory to become
available, for example.&lt;/p&gt;
&lt;p&gt;This is what the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mlock()&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mlockall()&lt;/span&gt;&lt;/code&gt; system calls are there
for - make sure that memory is available when it is needed. When
&lt;em&gt;locked into memory&lt;/em&gt;, mappings actually become populated with physical
memory. Thread stacks, for example, are physically eaten up as they
are created. Yes, realtime often brings contradictory requirements -
this is one. In such a scenario, as only one example, it does
absolutely make sense to pre-allocate limited stacks for each thread.&lt;/p&gt;
&lt;p&gt;But as always, you decide based upon what you know and, most of all,
upon your feeling. I wrote this rather lengthy post because I felt so
lucky that my feeling was right. “Can’t be!”. It cannot be that an OS
can be so stupid and eat up memory for nothing. I didn’t know 100%
sure, so I could have been wrong just as well. If you have read up to
this point at the end of kilometers of characters, then I hope you
agree with me about my conclusions. If not, please comment! One can
never be 100% sure, and I’d be glad to learn.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2012/04/Why-ps-sucks.html" rel="alternate"/>
    <summary>Process Stack Management</summary>
    <published>2012-04-03T00:00:00+02:00</published>
  </entry>
</feed>
