<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://www.faschingbauer.me</id>
  <title>Jörg Faschingbauer - Posted in 2012</title>
  <updated>2022-06-09T10:54:15.082239+00:00</updated>
  <link href="https://www.faschingbauer.me"/>
  <link href="https://www.faschingbauer.me/blog/2012/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.19">ABlog</generator>
  <entry>
    <id>https://www.faschingbauer.me/blog/2012/04/Why-ps-sucks.html</id>
    <title>“Why ps Sucks” or “Counting Memory Consumption”</title>
    <updated>2012-04-03T00:00:00+02:00</updated>
    <author>
      <name>Jörg Faschingbauer</name>
    </author>
    <content type="html">&lt;section id="why-ps-sucks-or-counting-memory-consumption"&gt;

&lt;aside class="sidebar"&gt;
&lt;p class="sidebar-title"&gt;Contents&lt;/p&gt;
&lt;div class="contents local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#process-stack-management" id="id2"&gt;Process Stack Management&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#conclusion" id="id3"&gt;Conclusion&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#thread-pthread-stack-management" id="id4"&gt;Thread (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread&lt;/span&gt;&lt;/code&gt;) Stack Management&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-1-100-default-threads-eating-no-stack" id="id5"&gt;Experiment #1: 100 default threads, eating no stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-2-100-default-threads-eating-up-stack" id="id6"&gt;Experiment #2: 100 default threads, eating up stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-3-100-threads-with-limited-stack" id="id7"&gt;Experiment #3: 100 threads with limited stack&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-4-more-threads-than-my-system-could-take-eat-no-stack" id="id8"&gt;Experiment #4: more threads than my system could take (eat no stack)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#experiment-5-more-threads-than-my-system-could-take-eat-stack" id="id9"&gt;Experiment #5: more threads than my system could take (eat stack)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#how-does-this-work" id="id10"&gt;How does this work?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#id1" id="id11"&gt;Conclusion&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="#realtime-is-different" id="id12"&gt;Realtime is different&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/aside&gt;
&lt;p&gt;Recently, I held a course on select topics around embedded Linux, at a
company in Zürich. The audience was pretty cool - they had ported
their appliance from a hardcore embedded OS to Linux a couple of years
ago. They are doing quite well nowadays. A bit too much realtime
attitude maybe (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SCHED_RR&lt;/span&gt;&lt;/code&gt; threads all over), but things appear to
work.&lt;/p&gt;
&lt;p&gt;On day 1, when we began to dive into multithreading (an inevitable
topic nowadays), an interesting question came up. “We have 70 threads
running, give each thread a stack size of 1 MB, and thus consume 70 MB
for the stacks alone. Add heap and program, and a couple of other
programs. Given a total memory of 128 MB, we’re soon dead.”&lt;/p&gt;
&lt;p&gt;“Can’t be!” was my first attempt to clear up the situation. The
attempt was rejected. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; output sure didn’t help a lot either. An
explanation of virtual memory (part of the course anyway) was the
second attempt, but still not bullet proof. More evidence
needed. Fortunately day 1 was over at this point, and I was left with
some overnight homework. During night I was able to come up with a
plausible screenplay in example form, to give a basic understanding of
how Linux does memory management. And that screenplay even backs my
instinctive “Can’t be!” defense. It’s these late night experiments
that I’m trying to share in this post.&lt;/p&gt;
&lt;section id="process-stack-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Process Stack Management&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First off, lets keep out multithreading and examine the stack behavior
of a plain old process. The following program grows the stack up to a
user supplied limit. Normally stack growth is done by calling
functions on top of other functions on top of … . This is a bit
cumbersome to program when you want to grow the stack up to a given
size, so I use a handy little tricky function, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca&lt;/span&gt;&lt;/code&gt;, to allocate
stack space. It does essentially the same - grow stack -, and I don’t
have to count stack addresses. Additionally, to be sure that the stack
is actually used (“dirty”), I set the allocated bytes to zero,
explicitly.&lt;/p&gt;
&lt;div class="highlight-c notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;alloca.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* stack-allocated bytes */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s stack-growth&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PID: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;done&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Compile like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;gcc -o process-stack process-stack.c
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So, lets start with a small stack,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 24299&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Examine the various size attributes of the process, using the cool
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;-o&lt;/span&gt;&lt;/code&gt; option to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;24299&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  3944   986   188   320&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, that’s really small. What do the columns mean? I sure don’t know -
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; is not very exact in its descriptions. Here’s my
interpretation.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;VSZ&lt;/span&gt;&lt;/code&gt; is the entire “virtual size”, whatever this means, in K. We
sure can’t attribute read-only mappings of shared libraries like
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;glibc&lt;/span&gt;&lt;/code&gt; to the process’s memory consumption - &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;glibc&lt;/span&gt;&lt;/code&gt;’s code is
shared between all processes that use it, and is resident in memory
&lt;em&gt;only once for all processes&lt;/em&gt;. Virtual memory basic usage, so to
say. The VSZ column tells us nothing about memory usage, I
presume.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SZ&lt;/span&gt;&lt;/code&gt; is the size of the “core image” of the process, in
pages. Whatever that is. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells me something about code,
stack, data. The page size on my system is 4K, which leads me to
assume that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SZ&lt;/span&gt;&lt;/code&gt; roughly equals &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;VSZ&lt;/span&gt;&lt;/code&gt;. I’m not interested in
code, so forget about this one either.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; looks promising, from what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt; &lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells me. “Amount of
swap that would be required if the process were to dirty all
writable pages and then be swapped out”. Allocated stack is dirtied
by definition, so this appears to be a good measure of stack
consumption - at least for our little stack-eater program. I assume
that the size unit is 1K because &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; is a little less than
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; (described below).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt;, “Resident set size”, in 1K units. This is the amount of
&lt;em&gt;non-swapped&lt;/em&gt; memory the process is currently using. This does
include in-core code pages as well, so this value is of limited
use. Furthermore, I consider &lt;em&gt;swapped&lt;/em&gt; memory relevant as well, and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; doesn’t count that.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; according to the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; column, allocating 10 bytes
on the stack leads me to a program that consumes 188K of main
memory. I suspect that this is the size of a minimal program anyway,
even if it does not consume anything.&lt;/p&gt;
&lt;p&gt;Anyway, let’s proceed with our tests and eat a million bytes stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;1000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 24908&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;24908&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  4800  1200  1044  1376&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, the columns have grown within reason and reflect what we
did. Next, we become a bit greedy and want ten million bytes&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;10000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 24960&lt;/span&gt;
&lt;span class="go"&gt;Segmentation fault&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We’ve hit the stack size limit 8MB which places a barrier against
greedy people,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -s
&lt;span class="go"&gt;8192&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Eight million bytes is ok, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; gives no surprise.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./process-stack &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 25018&lt;/span&gt;
&lt;span class="go"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;25018&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt; 11632  2908  7876  8236&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;section id="conclusion"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id3"&gt;Conclusion&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The stack of a process starts small and grows on demand, magically, up
to a limit. The logic is built in to the OS, which makes sense because
it does not make sense to have a process without a stack. The
operating system takes care of extending the stack by allocating
memory under the hood, and we don’t want to bother.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="thread-pthread-stack-management"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Thread (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread&lt;/span&gt;&lt;/code&gt;) Stack Management&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now for thread stacks. The story is a bit different here - POSIX
threads have an attribute “stack size”. It can be explicitly set using
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pthread_attr_setstacksize()&lt;/span&gt;&lt;/code&gt;, or left default which is 2MB or the
value of the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RLIMIT_STACK&lt;/span&gt;&lt;/code&gt; resource limit if that is set (see &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;man&lt;/span&gt;
&lt;span class="pre"&gt;pthread_create&lt;/span&gt;&lt;/code&gt;). A test program similar to the one above, but with
threads instead, would thus have the following parameters:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nthreads&lt;/span&gt;&lt;/code&gt;, the number of threads to create&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;stack-limit&lt;/span&gt;&lt;/code&gt;, the &lt;em&gt;stack size&lt;/em&gt; attribute of each thread. We call
it “limit” and not “size” as it will turn out that it is exactly
that.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;stack-growth&lt;/span&gt;&lt;/code&gt;, the number of bytes to allocate on the stack. This
is done using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca()&lt;/span&gt;&lt;/code&gt;, just like the process test program
does.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The program creates &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nthreads&lt;/span&gt;&lt;/code&gt; threads. Each thread acts like the
process example program above - allocate stack using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;alloca()&lt;/span&gt;&lt;/code&gt; and
then shut up and sit. It looks as follows.&lt;/p&gt;
&lt;div class="highlight-c notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* stack-allocated bytes */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;thread_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alloca&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s nthreads stack-limit stack-growth&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;stack_growth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PID: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_setstacksize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;set stack size to %ld: %s (%d)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strerror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pthread_attr_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack_limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;nthreads&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;pthread_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pthread_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p_attr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;thread_func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed after %d threads&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;pause&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Compile like so,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;gcc -pthread -o thread-stack thread-stack.c
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;section id="experiment-1-100-default-threads-eating-no-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id5"&gt;Experiment #1: 100 default threads, eating no stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let’s create a hundred threads with default stack size, each eating
100 bytes of stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;
&lt;span class="go"&gt;PID: 31524&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;31524&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;825840 206460 819936 1404&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So what? &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; reports the process as consuming over 800MB of
memory. According to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;’s description, “if it were to dirty all
writeable pages”, then this would be the amount of swap required. A
little calculation shows that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; is approximately 100 times
8MB. 8MB is the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RLIMIT_STACK&lt;/span&gt;&lt;/code&gt; resource limit that is configured on
my machine (check with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ulimit&lt;/span&gt; &lt;span class="pre"&gt;-s&lt;/span&gt;&lt;/code&gt;), and we started 100 threads. So
it appears that the process has allocated &lt;strong&gt;800MB worth of physical
memory pages, although only 100 bytes of each stack have been eaten&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;“Can’t be!” is what I said.&lt;/p&gt;
&lt;p&gt;Of course the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; field reports much less - but &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does not
report swapped memory, so we cannot count on it very much.&lt;/p&gt;
&lt;p&gt;But anyway - let’s accept the alleged waste of memory for a moment and
carry on with the experiments.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-2-100-default-threads-eating-up-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id6"&gt;Experiment #2: 100 default threads, eating up stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first experiment created 100 threads with default stack size 8MB,
and consumed almost nothing of the stacks. Lets eat up the stacks and
see what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports this time.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 771&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;771&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;825840 206460 819936 766604&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Aha. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; hasn’t changed, but &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; reports much more than the
last time around. Apparently &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does have value - at least on my
system where no swap is configured.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-3-100-threads-with-limited-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id7"&gt;Experiment #3: 100 threads with limited stack&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;See what effect a stack limit has.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;4096&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 1026&lt;/span&gt;
&lt;span class="go"&gt;set stack size to 4096: Invalid argument (22)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, we cannot limit the stack to only a single page. We don’t insist
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PTHREAD_STACK_MIN&lt;/span&gt;&lt;/code&gt; is 4 pages anyway), so lets increase stack size
and see what &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; tells us.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="m"&gt;16384&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 1125&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;1125&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;  7840  1960  1936  1404&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Well. 100 minimal threads lead to a process that consumes minimal
resources. Fine.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; Provided that we carefully limit our threads’ stacks,
we don’t eat up too much memory.&lt;/p&gt;
&lt;p&gt;Can’t be! Do I really have to fine-tune my stacks and risk stack
overflows and hard to find bugs?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-4-more-threads-than-my-system-could-take-eat-no-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id8"&gt;Experiment #4: more threads than my system could take (eat no stack)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now a definitive take: I have 64 bit address space, 4G of physical
RAM, and no swap configured. So, I could create no more than 512
threads with 8MB stack size each - 512*8MB == 4G. Let’s try that out
and create 513 threads. Each of the threads eats only 10 bytes of its
stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;513&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;span class="go"&gt;PID: 2212&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;2212&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;4210920 1052730 4205016 4576&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Works! &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports more &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt; than my system can take. What did
they say about &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SIZE&lt;/span&gt;&lt;/code&gt;, “&lt;em&gt;if it were to dirty all writeable pages&lt;/em&gt;”?
This suggests that pages totalling 4205016 bytes have been allocated
to the process. I don’t have that many pages, so it seems like I
misunderstand. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; seems to be definitive about the size.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="experiment-5-more-threads-than-my-system-could-take-eat-stack"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;Experiment #5: more threads than my system could take (eat stack)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Obviously the system permits its processes to “overcommit”
memory. Others still get their share. Nobody complained during
experiment #4, music kept playing without noticeable stutter. Now lets
actually use the stack.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;513&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 4353&lt;/span&gt;
&lt;span class="go"&gt;Killed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ok, that’s what I’d expect. Until the process was killed, the Red Hot
Chili Peppers had become overly funky (audio glitches all over), and
the Adobe Flash Plugin had crashed (Good Riddance). Less threads …&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;400&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;8000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 8462&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;ps -o vsz,sz,size,rss -p &lt;span class="m"&gt;8462&lt;/span&gt;
&lt;span class="go"&gt;   VSZ    SZ  SIZE   RSS&lt;/span&gt;
&lt;span class="go"&gt;3284640 821160 3278736 3064580&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It looks like I can create a bit more than 400 threads which eat up
their 8MB stacks. Not bad, as these numbers lie well within the
physical constraints of my machine.&lt;/p&gt;
&lt;p&gt;So, when I am able to create 400 threads which eat up their 8MB
(default) stacks, then I should be able to create about 800 threads
which eat up half of their 8MB stacks, right?&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;800&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;4000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 11338&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That was ok, try 900 threads …&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;./thread-stack &lt;span class="m"&gt;900&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;4000000&lt;/span&gt;
&lt;span class="go"&gt;PID: 12156&lt;/span&gt;
&lt;span class="go"&gt;Killed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Conclusion: We don’t have to fine-tune stacks!&lt;/strong&gt; Just as with the
process example, thread stacks are allocated &lt;em&gt;on demand&lt;/em&gt;, up to a
limit. A valid reason to decrease the stack size limit to a lower
value than the default is to keep it from eating up more memory than
expected. Stacks don’t shrink, so if I inadvertently - only once -
call a function that uses a 3MB automatic variable, I have a memory
leak.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="how-does-this-work"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;How does this work?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First, have a look at the way the Pthread library sets up a
thread. This is best done with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;strace&lt;/span&gt;&lt;/code&gt;. The system call to watch
out for is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt; is used to create both processes
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;fork()&lt;/span&gt;&lt;/code&gt; is implemented in terms of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;) and threads, just
with different kinds of flags.&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;strace -f ./thread-stack &lt;span class="m"&gt;30&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The output is rather long, I have tried to keep out the noise and show
only the interesting stuff. We have told the program to create 30
threads with default stack size 8MB. Hence we see 30 blocks like this
one,&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;[pid 14386] clone(child_stack=0x7f5813f22ff0,&lt;/span&gt;
&lt;span class="go"&gt;          flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHA...) = 14413&lt;/span&gt;
&lt;span class="go"&gt;[pid 14386] mmap(NULL, 8392704, PROT_READ|PROT_WRITE,&lt;/span&gt;
&lt;span class="go"&gt;          MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fd14f9af000&lt;/span&gt;
&lt;span class="go"&gt;[pid 14386] mprotect(0x7fd14f1ae000, 4096, PROT_NONE) = 0&lt;/span&gt;
&lt;span class="go"&gt;[pid 14413] pause( &amp;amp;lt;unfinished ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;What we see here is,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The main thread, 14386, creates a thread 14413 using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;clone()&lt;/span&gt;&lt;/code&gt;
with the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CLONE_VM&lt;/span&gt;&lt;/code&gt; flag and a few other flags. The kernel creates
a new “process” which shares the parent’s address space - which is
basically the definition of a thread.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The main thread allocates the requested stack using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mmap()&lt;/span&gt;&lt;/code&gt;. This
creates a &lt;em&gt;memory mapping&lt;/em&gt; - only a placeholder for memory, to be
allocated with pages &lt;em&gt;on demand&lt;/em&gt;, as memory is accessed. The memory
is accessible in the caller’s address space at address
0x7fd14f9af000, extending for 8392704 bytes. &lt;strong&gt;Note&lt;/strong&gt; that this is
4096 bytes more than the 8MB stack size.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The main thread protects 4096 bytes at the top of the stack (which
it has allocated in addition to what was requested) with
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PROT_NONE&lt;/span&gt;&lt;/code&gt;. Meaning that access to this part of the mapping will
lead to a segmentation fault. This is cheap and easy stack overflow
protection.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The created thread 14413 then calls &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pause()&lt;/span&gt;&lt;/code&gt;, which is what the
threads in our test program do after they have eaten their stack.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once mappings have been created, we can inspect them in the process’s
directory in the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem:&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;cat /proc/14386/maps
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1af000-7fd14f9af000 rw-p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;7fd14f9af000-7fd14f9b0000 ---p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;These two lines are the result of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mmap&lt;/span&gt; &lt;span class="pre"&gt;(PROT_READ|PROT_WRITE)&lt;/span&gt;&lt;/code&gt;,
followed by &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mprotect&lt;/span&gt; &lt;span class="pre"&gt;(PROT_NONE)&lt;/span&gt;&lt;/code&gt; of the topmost page. The first
line is the 8MB stack which has read/write access, the second line is
the “red” stack overflow protection page, without any access bits
set. Still this doesn’t show any details of the mapping; these can be
seen from another pseudo-file in the process’s &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; directory. (I
can imagine that the presence of a second file with redundant
information has historical reasons.)&lt;/p&gt;
&lt;div class="highlight-console notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$ &lt;/span&gt;cat /proc/14386/smaps
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1ae000-7fd14f1af000 ---p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;Size:                  4 kB&lt;/span&gt;
&lt;span class="go"&gt;Rss:                   0 kB&lt;/span&gt;
&lt;span class="go"&gt;Pss:                   0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Clean:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Dirty:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Clean:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Dirty:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Referenced:            0 kB&lt;/span&gt;
&lt;span class="go"&gt;Anonymous:             0 kB&lt;/span&gt;
&lt;span class="go"&gt;AnonHugePages:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Swap:                  0 kB&lt;/span&gt;
&lt;span class="go"&gt;KernelPageSize:        4 kB&lt;/span&gt;
&lt;span class="go"&gt;MMUPageSize:           4 kB&lt;/span&gt;
&lt;span class="go"&gt;Locked:                0 kB&lt;/span&gt;
&lt;span class="go"&gt;7fd14f1af000-7fd14f9af000 rw-p 00000000 00:00 0&lt;/span&gt;
&lt;span class="go"&gt;Size:               8192 kB&lt;/span&gt;
&lt;span class="go"&gt;Rss:                   8 kB&lt;/span&gt;
&lt;span class="go"&gt;Pss:                   8 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Clean:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Shared_Dirty:          0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Clean:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Private_Dirty:         8 kB&lt;/span&gt;
&lt;span class="go"&gt;Referenced:            8 kB&lt;/span&gt;
&lt;span class="go"&gt;Anonymous:             8 kB&lt;/span&gt;
&lt;span class="go"&gt;AnonHugePages:         0 kB&lt;/span&gt;
&lt;span class="go"&gt;Swap:                  0 kB&lt;/span&gt;
&lt;span class="go"&gt;KernelPageSize:        4 kB&lt;/span&gt;
&lt;span class="go"&gt;MMUPageSize:           4 kB&lt;/span&gt;
&lt;span class="go"&gt;Locked:                0 kB&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here we see the same two mappings, but with additional information. It
is exactly this information that we are missing from &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first mapping represents the red page. Its size is 4K. No &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt;,
no nothing else. Pretty shallow, not backed by any physical memory.&lt;/p&gt;
&lt;p&gt;The second mapping is the stack itself, with the following
information:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The mapping’s extent (Size) is 8MB which is no surprise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;8K is currently resident. Again, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;RSS&lt;/span&gt;&lt;/code&gt; does not help much as the
number is swamped by swap.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The most important information is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Private_Dirty&lt;/span&gt;&lt;/code&gt; - the number of
bytes that are “dirty” and thus have to be allocated and attributed
to the process. “Private” means that the memory is not shared with
any other process (stacks are not shared of course), and thus the
memory is attributed &lt;em&gt;only to the process&lt;/em&gt;. Here we can see that,
although the size of the mapping is 8MB, &lt;strong&gt;only 8K are actually
used&lt;/strong&gt;. As it happens the same amount is also resident, but again,
this need not be.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;Conclusion&lt;/a&gt;&lt;/h2&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: INFO/1 (&lt;span class="docutils literal"&gt;/home/jfasch/work/jfasch-home/blog/2012/04/Why-ps-sucks.rst&lt;/span&gt;, line 586); &lt;em&gt;&lt;a href="#id1"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Duplicate implicit target name: “conclusion”.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;There’s no reason to panic when &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ps&lt;/span&gt;&lt;/code&gt; reports large numbers. It’s
just not easy to find out how much memory a process actually
consumes. By understanding the information the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem
provides, you at least have the chance to find out what you need.&lt;/p&gt;
&lt;p&gt;What is most important to understand is the &lt;em&gt;on demand&lt;/em&gt; nature of
memory allocation. That the &lt;em&gt;size&lt;/em&gt; of a memory mapping is definitely
meaningless, and that mappings are “filled” with memory pages as
memory is actually accessed. Stacks are actually nothing but mappings
as we saw above. The same principle applies to the heap
(&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc/PID/maps&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc/PID/smaps&lt;/span&gt;&lt;/code&gt; actually report a mapping
named “heap”), program code (a mapping which is shared between many
processes and which is read-only), global read-only and read-write
data (the latter is copied on-demand and only then attributed to the
modifying process). There are many other usages of memory mappings -
dig through the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/proc&lt;/span&gt;&lt;/code&gt; filesystem to find
out. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Documentation/filesystems/proc.txt&lt;/span&gt;&lt;/code&gt; from the Linux kernel
source code gives a thorough explanation of the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;smaps&lt;/span&gt;&lt;/code&gt; entries, and
much more.&lt;/p&gt;
&lt;section id="realtime-is-different"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Realtime is different&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;On demand&lt;/em&gt; memory allocation is counter productive in a realtime
scenario as it can delay execution substantially. To overcome this
situation, one needs to make sure memory is actually available
beforehand. No way &lt;em&gt;having to wait&lt;/em&gt; for stack memory to become
available, for example.&lt;/p&gt;
&lt;p&gt;This is what the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mlock()&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mlockall()&lt;/span&gt;&lt;/code&gt; system calls are there
for - make sure that memory is available when it is needed. When
&lt;em&gt;locked into memory&lt;/em&gt;, mappings actually become populated with physical
memory. Thread stacks, for example, are physically eaten up as they
are created. Yes, realtime often brings contradictory requirements -
this is one. In such a scenario, as only one example, it does
absolutely make sense to pre-allocate limited stacks for each thread.&lt;/p&gt;
&lt;p&gt;But as always, you decide based upon what you know and, most of all,
upon your feeling. I wrote this rather lengthy post because I felt so
lucky that my feeling was right. “Can’t be!”. It cannot be that an OS
can be so stupid and eat up memory for nothing. I didn’t know 100%
sure, so I could have been wrong just as well. If you have read up to
this point at the end of kilometers of characters, then I hope you
agree with me about my conclusions. If not, please comment! One can
never be 100% sure, and I’d be glad to learn.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://www.faschingbauer.me/blog/2012/04/Why-ps-sucks.html" rel="alternate"/>
    <summary>Process Stack Management</summary>
    <published>2012-04-03T00:00:00+02:00</published>
  </entry>
</feed>
